//! # Semantic Analyser
//!
//! Responsible for performing semantic analysis on the abstract syntax tree (AST) generated by
//! the parser. This analysis ensures that the code is semantically correct according to
//! the language's rules, checking for issues such as type mismatches, undefined variables
//! and incorrect patterns in the code.

mod expr;
mod patt;
mod symbol_table;

#[cfg(test)]
mod tests;

mod utils;

use std::{collections::HashMap, rc::Rc};

use crate::{
    ast::{
        AliasDecl, ConstantDecl, EnumDef, EnumVariantKind, EnumVariantStruct,
        EnumVariantTupleStruct, Expression, FunctionItem, FunctionOrMethodParam, FunctionParam,
        GenericParam, Identifier, ImportDecl, InherentImplDef, InherentImplItem, Item, Keyword,
        ModuleItem, ReferenceOp, Statement, StaticVarDecl, StructDef, StructDefField, TraitDef,
        TraitDefItem, TraitImplDef, TraitImplItem, TupleStructDef, TupleStructDefField, Type,
        TypePath, UnitType, Visibility,
    },
    error::{CompilerError, SemanticErrorKind},
    log_debug, log_error, log_info, log_trace, log_warn,
    logger::{LogLevel, Logger},
    parser::{get_type_paths, Program},
    span::{Span, Spanned},
};

pub(crate) use self::utils::*;

use self::expr::analyse_expr;
use self::symbol_table::{Module, Scope, ScopeKind, Symbol, SymbolTable};

type LibRegistry = HashMap<Identifier, Vec<Module>>;

/// Mapping from a `TypePath` (representing a concrete type) to a `Vec<TraitImplDef>`
/// (representing implemented traits)
type TypeTable = HashMap<TypePath, Vec<TraitImplDef>>;

/// Struct responsible for performing semantic analysis on the abstract syntax tree (AST)
/// of the program. It manages the scopes, symbol tables and errors encountered during
/// the analysis phase. It also keeps track of implemented trait for a given type.
struct SemanticAnalyser {
    scope_stack: Vec<Scope>,
    lib_registry: LibRegistry,
    type_table: TypeTable,
    errors: Vec<CompilerError<SemanticErrorKind>>,
    logger: Logger,
}

#[allow(dead_code)]
impl SemanticAnalyser {
    /// Construct a new `SemanticAnalyser` instance. Initialize the logger, external symbols
    /// and module registry. Add any external code (e.g., library functions) to the global scope
    /// if provided.
    fn new(log_level: LogLevel, external_code: Option<LibRegistry>) -> Self {
        let mut logger = Logger::init(log_level);
        let mut symbols: SymbolTable = HashMap::new();
        let mut lib_registry: LibRegistry = HashMap::new();

        if let Some(code) = external_code {
            log_debug!(
                logger,
                "external code detected – importing code from {:?}",
                code.keys()
            );

            for (lib_name, lib_contents) in code {
                for module in lib_contents.iter().cloned() {
                    for (path, sym) in module.table {
                        symbols.insert(path, sym);
                    }
                }

                lib_registry.insert(lib_name, lib_contents);
            }
        }

        let public_scope = Scope {
            scope_kind: ScopeKind::Public,
            symbols,
        };

        log_trace!(logger, "entering public scope …");

        SemanticAnalyser {
            scope_stack: vec![public_scope],
            lib_registry,
            errors: Vec::new(),
            logger,
            type_table: HashMap::new(),
        }
    }

    /// Push a new scope onto the scope stack and log the action.
    fn enter_scope(&mut self, scope_kind: ScopeKind) {
        log_debug!(self.logger, "entering new scope: `{scope_kind}` …");

        self.scope_stack.push(Scope {
            scope_kind: scope_kind,
            symbols: HashMap::new(),
        });
    }

    /// Pop the top scope from the scope stack and log the action.
    fn exit_scope(&mut self) -> Option<Scope> {
        if let Some(exited_scope) = self.scope_stack.pop() {
            log_debug!(self.logger, "exited scope: `{}`", exited_scope.scope_kind);
            log_trace!(
                self.logger,
                "current_scope: `{}`",
                self.scope_stack
                    .last()
                    .unwrap_or(&Scope {
                        scope_kind: ScopeKind::Public,
                        symbols: HashMap::new()
                    })
                    .scope_kind
            );

            Some(exited_scope)
        } else {
            None
        }
    }

    /// Insert a symbol into the current scope's symbol table.
    fn insert(&mut self, path: TypePath, symbol: Symbol) -> Result<(), SemanticErrorKind> {
        if let Some(curr_scope) = self.scope_stack.last_mut() {
            log_debug!(
                self.logger,
                "inserting symbol `{symbol}` into scope `{}` at path `{path}` …",
                curr_scope.scope_kind
            );

            curr_scope.symbols.insert(path, symbol);

            // if let Some(modules) = self.lib_registry.get_mut(&Identifier::from("lib")) {
            //     for module in modules.iter_mut() {
            //         if module.name == path.type_name {
            //             module.table.insert(path.clone(), symbol.clone());
            //         }
            //     }
            // }

            Ok(())
        } else {
            Err(SemanticErrorKind::UndefinedScope)
        }
    }

    fn insert_into_module_scope(
        &mut self,
        path: TypePath,
        symbol: Symbol,
    ) -> Result<(), SemanticErrorKind> {
        let mut iter = self.scope_stack.iter().cloned().rev();

        let mut index = 0usize;

        while let Some(next) = iter.next() {
            index += 1;

            if matches!(next.scope_kind, ScopeKind::Module { .. }) {
                break;
            }
        }

        let scope = self.scope_stack.get_mut(index).unwrap();

        log_debug!(
            self.logger,
            "inserting symbol `{symbol}` into scope `{}` at path `{path}` …",
            scope.scope_kind
        );

        scope.symbols.insert(path, symbol);

        Ok(())
    }

    /// Look up a symbol by its path in the current scope stack, starting from the innermost scope,
    /// and log the lookup result.
    fn lookup(&mut self, path: &TypePath) -> Option<&Symbol> {
        for scope in self.scope_stack.iter().rev() {
            if let Some(symbol) = scope.symbols.get(path) {
                log_debug!(
                    self.logger,
                    "found symbol `{symbol}` in scope `{}` at path `{path}`",
                    scope.scope_kind
                );

                return Some(symbol);
            } else {
                for (sym_path, symbol) in scope.symbols.iter() {
                    if *path == sym_path.clone().strip_prefix() {
                        log_debug!(
                            self.logger,
                            "found symbol `{symbol}` in scope `{}` at path `{path}`",
                            scope.scope_kind
                        );

                        return Some(symbol);
                    }
                }
            }
        }

        log_warn!(self.logger, "path `{path:?}` not found in current scope");

        None
    }

    /// Initiate semantic analysis on the provided program. This involves analysing all statements
    /// within the program, checking for type mismatches and validating symbol definitions.
    fn analyse_program(
        &mut self,
        program: &Program,
    ) -> Result<(), Vec<CompilerError<SemanticErrorKind>>> {
        log_debug!(self.logger, "starting semantic analysis …");

        self.enter_scope(ScopeKind::ProgramRoot);

        self.lib_registry
            .insert(Identifier::from("lib"), Vec::new());

        for stmt in &program.statements {
            self.analyse_stmt(stmt, Identifier::from("").to_type_path())
                .map_err(|_| self.errors.to_vec())?
        }

        self.exit_scope();

        if !self.errors.is_empty() {
            return Err(self.errors.to_vec());
        }

        log_info!(
            self.logger,
            "semantic analysis successful, no errors detected"
        );

        Ok(())
    }

    // TODO: add custom errors to specify context when unifying types
    // TODO: (e.g., function args / struct fields)

    /// Analyse individual statements within the program, determining their validity and handling
    /// specific types of statements, such as variable declarations, item definitions and expressions.
    /// Check for semantic correctness and ensures that the statement adheres to the expected types
    /// and scope rules.
    fn analyse_stmt(
        &mut self,
        statement: &Statement,
        root: TypePath,
    ) -> Result<(), SemanticErrorKind> {
        match statement {
            Statement::Expression(expr) => {
                log_trace!(self.logger, "analysing expression statement: `{statement}`");

                match analyse_expr(self, expr, &root) {
                    Ok(_) => (),
                    Err(e) => self.log_error(e, &expr.span()),
                }
            }

            Statement::Item(item) => match item {
                Item::AliasDecl(ad) => {
                    // log_trace!(self.logger, "analysing alias declaration: `{statement}`");

                    let alias_decl = Rc::new(ad);

                    let alias_path = root.clone_append(alias_decl.alias_name.to_type_path());

                    self.try_update_current_scope(
                        &ScopeKind::ProgramRoot,
                        ScopeKind::Module(Identifier::from("lib").to_type_path()),
                    );

                    self.insert(
                        alias_path.clone(),
                        Symbol::Alias {
                            path: alias_path,
                            visibility: alias_decl.visibility,
                            alias_name: alias_decl.alias_name.clone(),
                            original_type_opt: alias_decl.original_type_opt.clone(),
                        },
                    )?;
                }

                Item::ConstantDecl(cd) => {
                    let constant_decl = Rc::new(cd);

                    log_trace!(self.logger, "analysing constant declaration: `{statement}`");

                    let value_type = match &constant_decl.value_opt {
                        Some(val) => {
                            let value = val.to_expression();
                            Some(analyse_expr(self, &value, &root)?)
                        }
                        _ => None,
                    };

                    self.check_types(
                        &mut self.current_symbol_table(),
                        &constant_decl.constant_type.clone(),
                        &mut value_type.clone().unwrap_or(Type::inferred_type("_")),
                    )?;

                    if value_type
                        .clone()
                        .is_some_and(|t| t != *constant_decl.constant_type)
                    {
                        return Err(SemanticErrorKind::TypeMismatchDeclaredType {
                            declared_type: *constant_decl.constant_type.clone(),
                            actual_type: value_type.unwrap(),
                        });
                    }

                    let constant_path =
                        root.clone_append(constant_decl.constant_name.to_type_path());

                    self.try_update_current_scope(
                        &ScopeKind::ProgramRoot,
                        ScopeKind::Module(Identifier::from("lib").to_type_path()),
                    );

                    if let Some(Scope { scope_kind, .. }) = self.scope_stack.last() {
                        if matches!(scope_kind, ScopeKind::TraitImpl { .. }) {
                            return self.insert_into_module_scope(
                                constant_path.clone(),
                                Symbol::Constant {
                                    path: constant_path,
                                    visibility: constant_decl.visibility,
                                    constant_name: constant_decl.constant_name.clone(),
                                    constant_type: value_type.unwrap_or(Type::inferred_type("_")),
                                },
                            );
                        }
                    }

                    self.insert(
                        constant_path.clone(),
                        Symbol::Constant {
                            path: constant_path,
                            visibility: constant_decl.visibility,
                            constant_name: constant_decl.constant_name.clone(),
                            constant_type: value_type.unwrap_or(Type::inferred_type("_")),
                        },
                    )?;
                }

                Item::EnumDef(e) => {
                    let enum_def = Rc::new(e.clone());

                    let enum_name_path = enum_def.enum_name.to_type_path();
                    let enum_def_path = root.clone_append(enum_name_path.clone());

                    // log_trace!(
                    //     self.logger,
                    //     "analysing enum definition: `{enum_def_path}` …"
                    // );

                    self.try_update_current_scope(
                        &ScopeKind::ProgramRoot,
                        ScopeKind::Module(Identifier::from("lib").to_type_path()),
                    );

                    self.insert(
                        enum_def_path.clone(),
                        Symbol::Enum {
                            path: enum_name_path,
                            enum_def,
                            associated_items_inherent: Vec::new(),
                            associated_items_trait: Vec::new(),
                        },
                    )?;

                    for variant in e.variants.iter() {
                        self.insert(
                            variant.variant_path.clone(),
                            Symbol::Variable {
                                name: variant.variant_path.to_identifier(),
                                var_type: Type::UserDefined(variant.variant_path.clone()),
                            },
                        )?;
                    }
                }

                Item::FunctionItem(fi) => {
                    let function_item = Rc::new(fi.clone());

                    let function_name_path = function_item.function_name.to_type_path();
                    let function_item_path = root.clone_append(function_name_path.clone());

                    self.try_update_current_scope(
                        &ScopeKind::ProgramRoot,
                        ScopeKind::Module(Identifier::from("lib").to_type_path()),
                    );

                    self.insert(
                        function_item_path.clone(),
                        Symbol::Function {
                            path: function_name_path,
                            function: function_item.clone(),
                        },
                    )?;

                    match self.analyse_function_def(&function_item, &root, false, false) {
                        Ok(_) => (),
                        Err(err) => {
                            self.log_error(err, &function_item.span);
                        }
                    }
                }

                Item::ImportDecl(id) => {
                    log_trace!(self.logger, "analysing import declaration: `{statement}`");

                    match self.analyse_import(id, &root.type_name) {
                        Ok(_) => (),
                        Err(err) => self.log_error(err, &id.span),
                    }

                    log_trace!(self.logger, "import declaration analysis complete");
                }

                Item::InherentImplDef(iid) => {
                    let type_path = root.clone_append(iid.nominal_type.clone());

                    log_trace!(
                        self.logger,
                        "analysing inherent implementation for type: `{type_path}` …",
                    );

                    let scope_kind = ScopeKind::Impl(type_path.clone());

                    let mut function_symbols: SymbolTable = HashMap::new();

                    self.enter_scope(scope_kind);

                    if let Some(items) = &iid.associated_items_opt {
                        let mut object_symbol = if let Some(s) = self.lookup(&type_path) {
                            s.to_owned()
                        } else {
                            return Err(SemanticErrorKind::MissingItem {
                                expected: "struct or enum".to_string(),
                            });
                        };

                        for i in items.iter() {
                            println!("inherent impl item: {i:?}",);

                            match i {
                                InherentImplItem::ConstantDecl(cd) => self.analyse_stmt(
                                    &Statement::Item(Item::ConstantDecl(cd.clone())),
                                    type_path.clone(),
                                )?,
                                InherentImplItem::FunctionItem(fi) => {
                                    let function_item = Rc::new(fi.clone());

                                    let function_name_path =
                                        function_item.function_name.to_type_path();

                                    let function_def_path =
                                        type_path.clone_append(function_name_path.clone());

                                    function_symbols.insert(
                                        function_def_path.clone(),
                                        Symbol::Function {
                                            path: function_name_path,
                                            function: function_item.clone(),
                                        },
                                    );

                                    match self.analyse_function_def(
                                        &function_item,
                                        &type_path,
                                        true,
                                        false,
                                    ) {
                                        Ok(_) => (),
                                        Err(err) => self.log_error(err, &iid.span),
                                    }
                                }
                            }

                            object_symbol.add_associated_items(Some(i.clone()), None)?;
                        }
                    }

                    self.exit_scope();

                    for (path, symbol) in function_symbols {
                        self.insert(path, symbol)?;
                    }
                }

                Item::ModuleItem(m) => {
                    // TODO: sort out visibility

                    let mut module_errors: Vec<SemanticErrorKind> = Vec::new();

                    let module_path = root.clone_append(m.module_name.to_type_path());

                    let scope_kind = ScopeKind::Module(module_path.clone());

                    let mut module_scope = Scope {
                        scope_kind: scope_kind.clone(),
                        symbols: HashMap::new(),
                    };

                    log_trace!(self.logger, "analysing items in module `{module_path}` …");

                    self.enter_scope(scope_kind);

                    if let Some(items) = &m.items_opt {
                        for item in items.iter() {
                            match self.analyse_stmt(
                                &Statement::Item(item.clone()),
                                m.module_name.to_type_path(),
                            ) {
                                Ok(_) => (),
                                Err(err) => {
                                    self.log_error(err.clone(), &item.span());
                                    module_errors.push(err)
                                }
                            }
                        }
                    }

                    if !module_errors.is_empty() {
                        return Err(SemanticErrorKind::ModuleErrors {
                            name: m.module_name.clone(),
                        });
                    }

                    log_trace!(self.logger, "module analysis complete");

                    if let Some(curr_scope) = self.scope_stack.pop() {
                        log_debug!(self.logger, "exited scope: `{}`", curr_scope.scope_kind);
                        log_trace!(
                            self.logger,
                            "current_scope: `{}`",
                            self.scope_stack
                                .last()
                                .unwrap_or(&Scope {
                                    scope_kind: ScopeKind::Public,
                                    symbols: HashMap::new()
                                })
                                .scope_kind
                        );

                        module_scope = curr_scope;
                    }

                    self.insert(
                        module_path.clone(),
                        Symbol::Module {
                            path: module_path,
                            module: m.clone(),
                            symbols: module_scope.symbols.clone(),
                        },
                    )?;

                    if let Some(lib_contents) = self.lib_registry.get_mut(&Identifier::from("lib"))
                    {
                        log_trace!(
                            self.logger,
                            "inserting module `{}` into library registry under library `lib` …",
                            m.module_name
                        );

                        let module = Module {
                            name: m.module_name.clone(),
                            table: module_scope.symbols,
                        };

                        lib_contents.push(module);
                    }
                }

                Item::StaticVarDecl(s) => {
                    log_trace!(
                        self.logger,
                        "analysing static variable declaration: `{statement}`"
                    );

                    let mut assignee_type = match &s.assignee_opt {
                        Some(a_expr) => {
                            let assignee = a_expr.to_expression();
                            analyse_expr(self, &assignee, &root)?
                        }
                        _ => Type::inferred_type("_"),
                    };

                    self.check_types(
                        &mut self.current_symbol_table(),
                        &s.var_type,
                        &mut assignee_type,
                    )?;

                    if &assignee_type != &s.var_type {
                        return Err(SemanticErrorKind::TypeMismatchDeclaredType {
                            declared_type: s.var_type.clone(),
                            actual_type: assignee_type,
                        });
                    }

                    let static_var_path = root.clone_append(s.var_name.to_type_path());

                    self.try_update_current_scope(
                        &ScopeKind::ProgramRoot,
                        ScopeKind::Module(Identifier::from("lib").to_type_path()),
                    );

                    self.insert(
                        static_var_path,
                        Symbol::Variable {
                            name: s.var_name.clone(),
                            var_type: s.var_type.clone(),
                        },
                    )?;
                }

                Item::StructDef(s) => {
                    let struct_def = Rc::new(s.clone());
                    let struct_name_path = struct_def.struct_name.to_type_path();
                    let struct_def_path = root.clone_append(struct_name_path.clone());

                    // log_trace!(
                    //     self.logger,
                    //     "analysing struct definition: `{struct_def_path}` …"
                    // );

                    self.try_update_current_scope(
                        &ScopeKind::ProgramRoot,
                        ScopeKind::Module(Identifier::from("lib").to_type_path()),
                    );

                    self.insert(
                        struct_def_path,
                        Symbol::Struct {
                            path: struct_name_path,
                            struct_def: struct_def,
                            associated_items_inherent: Vec::new(),
                            associated_items_trait: Vec::new(),
                        },
                    )?;
                }

                Item::TraitDef(t) => {
                    let trait_def = Rc::new(t.clone());

                    let trait_name_path = trait_def.trait_name.to_type_path();
                    let trait_def_path = root.clone_append(trait_name_path.clone());

                    self.try_update_current_scope(
                        &ScopeKind::ProgramRoot,
                        ScopeKind::Module(Identifier::from("lib").to_type_path()),
                    );

                    self.insert(
                        trait_def_path.clone(),
                        Symbol::Trait {
                            path: trait_name_path.clone(),
                            trait_def: trait_def.clone(),
                        },
                    )?;

                    log_trace!(
                        self.logger,
                        "analysing trait definition: `{trait_def_path}` …"
                    );

                    // let scope_kind = ScopeKind::Impl(trait_def_path.clone());

                    // let mut symbols: HashMap<TypePath, Symbol> = HashMap::new();

                    // self.enter_scope(scope_kind);

                    if let Some(items) = &trait_def.trait_items_opt {
                        // let mut trait_symbol = if let Some(s) = self.lookup(&trait_def_path) {
                        //     s.to_owned()
                        // } else {
                        //     return Err(SemanticErrorKind::MissingItem {
                        //         expected: "trait symbol".to_string(),
                        //     });
                        // };

                        for i in items.iter().cloned() {
                            // let item =

                            match i {
                                TraitDefItem::AliasDecl(ad) => {
                                    self.analyse_stmt(
                                        &Statement::Item(Item::AliasDecl(ad)),
                                        trait_def_path.clone(),
                                    )?;

                                    // TraitImplItem::AliasDecl(ad.clone())
                                }
                                TraitDefItem::ConstantDecl(cd) => {
                                    self.analyse_stmt(
                                        &Statement::Item(Item::ConstantDecl(cd)),
                                        trait_def_path.clone(),
                                    )?;

                                    // TraitImplItem::ConstantDecl(cd.clone())
                                }

                                TraitDefItem::FunctionItem(fi) => {
                                    let function_item = Rc::new(fi);

                                    let function_name_path =
                                        function_item.function_name.to_type_path();

                                    let function_def_path =
                                        trait_def_path.clone_append(function_name_path.clone());

                                    if function_item.block_opt.clone().is_some_and(|block| {
                                        block.statements_opt.is_some_and(|stmts| !stmts.is_empty())
                                    }) {
                                        log_trace!(self.logger, "found default implementation for trait function: `{function_def_path}`")
                                    }

                                    self.insert(
                                        function_def_path,
                                        Symbol::Function {
                                            path: function_name_path,
                                            function: function_item.clone(),
                                        },
                                    )?;

                                    // symbols.insert(
                                    //     function_def_path,
                                    //     Symbol::Function {
                                    //         path: function_name_path,
                                    //         function: fi.clone(),
                                    //     },
                                    // );

                                    match self.analyse_function_def(
                                        &function_item,
                                        &trait_def_path,
                                        false,
                                        false,
                                    ) {
                                        Ok(_) => (),
                                        Err(err) => self.log_error(err, &trait_def.span),
                                    }

                                    // TraitImplItem::FunctionItem(fi.clone())
                                }
                            };

                            // trait_symbol.add_associated_items(None, Some(item))?;
                        }
                    }

                    // self.exit_scope();

                    // log_trace!(
                    //     self.logger,
                    //     "inserting symbols into implementation for type: `{trait_def_path}` …",
                    // );

                    // for (path, symbol) in symbols {
                    //     self.insert(path, symbol)?;
                    // }
                }

                Item::TraitImplDef(t) => {
                    let implementing_type_path = match &t.implementing_type {
                        Type::UserDefined(tp) => root.clone_append(tp.clone()),

                        ty => {
                            return Err(SemanticErrorKind::UnexpectedType {
                                expected: "user-defined type".to_string(),
                                found: ty.clone(),
                            })
                        }
                    };

                    let trait_def = match self.lookup(&t.implemented_trait_path).cloned() {
                        Some(Symbol::Trait { trait_def, .. }) => trait_def,

                        Some(sym) => {
                            return Err(SemanticErrorKind::UnexpectedSymbol {
                                name: t.implemented_trait_path.to_identifier(),
                                expected: "trait definition".to_string(),
                                found: sym.to_backtick_string(),
                            })
                        }

                        None => {
                            return Err(SemanticErrorKind::UndefinedType {
                                name: t.implemented_trait_path.to_identifier(),
                            });
                        }
                    };

                    let trait_impl_path = implementing_type_path
                        .clone_append(t.implemented_trait_path.type_name.to_type_path());

                    log_trace!(
                        self.logger,
                        "analysing implementation of trait `{}` for type `{}` …",
                        t.implemented_trait_path,
                        t.implementing_type
                    );

                    self.add_trait_implementation(trait_impl_path.clone(), t.clone());

                    let scope_kind = ScopeKind::TraitImpl {
                        implemented_trait_path: t.implemented_trait_path.clone(),
                        implementing_type_path: implementing_type_path.clone(),
                    };

                    let mut function_symbols: SymbolTable = HashMap::new();

                    self.enter_scope(scope_kind);

                    self.analyse_trait_impl_items(
                        &trait_def,
                        t,
                        &implementing_type_path,
                        trait_impl_path,
                        &mut function_symbols,
                    )?;

                    self.exit_scope();

                    for (path, symbol) in function_symbols {
                        self.insert(path, symbol)?;
                    }
                }

                Item::TupleStructDef(ts) => {
                    let tuple_struct_def = Rc::new(ts.clone());

                    let struct_name_path = tuple_struct_def.struct_name.to_type_path();
                    let tuple_struct_path = root.clone_append(struct_name_path.clone());

                    // log_trace!(
                    //     self.logger,
                    //     "analysing tuple struct definition: `{tuple_struct_path}` …"
                    // );

                    self.try_update_current_scope(
                        &ScopeKind::ProgramRoot,
                        ScopeKind::Module(Identifier::from("lib").to_type_path()),
                    );

                    self.insert(
                        tuple_struct_path,
                        Symbol::TupleStruct {
                            path: struct_name_path,
                            tuple_struct_def,
                            associated_items_inherent: Vec::new(),
                            associated_items_trait: Vec::new(),
                        },
                    )?;
                }
            },

            Statement::Let(ls) => {
                log_trace!(self.logger, "analysing let statement: `{statement}`");

                // variables declared must have a type and are assigned the unit type if not;
                // this prevents uninitialized variable errors
                let mut value_type = if let Some(val) = &ls.value_opt {
                    analyse_expr(self, val, &root)?
                } else {
                    Type::UNIT_TYPE
                };

                // get the type annotation if there is one, otherwise assume the value's type
                let declared_type = match &ls.type_ann_opt {
                    Some(ty) => ty.clone(),
                    _ => value_type.clone(),
                };

                self.check_types(
                    &mut self.current_symbol_table(),
                    &declared_type,
                    &mut value_type,
                )?;

                // check that the value matches the type annotation
                if &value_type != &declared_type {
                    return Err(SemanticErrorKind::TypeMismatchDeclaredType {
                        actual_type: value_type,
                        declared_type,
                    });
                }

                let assignee_path = ls.assignee.name.to_type_path();

                let symbol = match &value_type {
                    Type::I32
                    | Type::I64
                    | Type::U8
                    | Type::U16
                    | Type::U32
                    | Type::U64
                    | Type::U256
                    | Type::U512
                    | Type::F32
                    | Type::F64
                    | Type::Byte
                    | Type::B2
                    | Type::B4
                    | Type::B8
                    | Type::B16
                    | Type::B32
                    | Type::H160
                    | Type::H256
                    | Type::H512
                    | Type::Str
                    | Type::Char
                    | Type::Bool
                    | Type::UnitType(_)
                    | Type::GroupedType(_)
                    | Type::Array { .. }
                    | Type::Tuple(_)
                    | Type::FunctionPtr(_)
                    | Type::Reference { .. }
                    | Type::SelfType { .. }
                    | Type::InferredType(_)
                    | Type::Vec { .. }
                    | Type::Mapping { .. }
                    | Type::Option { .. }
                    | Type::Result { .. } => Symbol::Variable {
                        name: ls.assignee.name.clone(),
                        var_type: value_type,
                    },
                    Type::UserDefined(tp) => match self.lookup(&tp) {
                        Some(Symbol::Enum { path, .. }) => Symbol::Variable {
                            name: ls.assignee.name.clone(),
                            var_type: Type::UserDefined(path.clone()),
                        },
                        Some(sym) => sym.clone(),
                        _ => Symbol::Variable {
                            name: ls.assignee.name.clone(),
                            var_type: value_type,
                        },
                    },
                    Type::Generic(GenericParam {
                        name,
                        type_bound_opt,
                    }) => Symbol::Variable {
                        name: name.clone(),
                        var_type: Type::UserDefined(
                            type_bound_opt
                                .clone()
                                .unwrap_or(Identifier::from("_").to_type_path()),
                        ),
                    },
                };

                // add the variable to the symbol table
                self.insert(assignee_path, symbol)?;
            }
        }

        Ok(())
    }

    /// Analyse a function definition within a specific context, including its parameters,
    /// body, and return type.
    fn analyse_function_def(
        &mut self,
        f: &FunctionItem,
        path: &TypePath,
        is_associated_func: bool,
        is_trait_impl: bool,
    ) -> Result<(), SemanticErrorKind> {
        // What is the root path? [i.e., path to the function, excluding the function name]
        // Options:
        // * module (e.g., `lib::some_module` or just `lib`)
        // * object implementation (e.g., `lib::some_module::SomeObject`)
        // * trait implementation (e.g., `lib::some_module::SomeObject::SomeTrait`)

        let function_root = path.clone();

        // append the function name to the root
        let full_path = function_root.clone_append(f.function_name.to_type_path());

        log_trace!(
            self.logger,
            "analysing function item: `{full_path}({:?}) -> {}` …",
            f.param_strings(),
            f.return_type_opt
                .clone()
                .unwrap_or(Box::new(Type::UNIT_TYPE))
        );

        self.enter_scope(ScopeKind::FunctionDef(full_path.clone()));

        // register generic parameters in the local scope
        if let Some(generic_params) = &f.generic_params_opt {
            for generic_param in &generic_params.params {
                self.insert(
                    generic_param.name.to_type_path(),
                    Symbol::Variable {
                        name: generic_param.name.clone(),
                        var_type: generic_param.to_type(),
                    },
                )?;
            }
        }

        if let Some(params) = &f.params_opt {
            let param_types: Vec<Type> = params.iter().map(|p| p.param_type()).collect();

            for (param, mut param_type) in params.iter().zip(param_types) {
                if let Type::SelfType { reference_op, .. } = param_type {
                    let inner_type = if is_trait_impl {
                        Type::UserDefined(function_root.clone().strip_suffix())
                    } else {
                        Type::UserDefined(function_root.clone())
                    };

                    if is_associated_func {
                        param_type = match reference_op {
                            ReferenceOp::Borrow | ReferenceOp::MutableBorrow => Type::Reference {
                                reference_op,
                                inner_type: Box::new(inner_type),
                            },
                            ReferenceOp::Owned => inner_type,
                        };
                    }
                }

                let param_path = param.param_name().to_type_path();

                self.analyse_function_params(param_type, param_path, param)?;
            }
        }

        if let Some(block) = &f.block_opt {
            let root = path.clone().strip_suffix();

            // self.enter_scope(ScopeKind::FunctionBody(full_path.clone()));

            let mut function_type = analyse_expr(self, &Expression::Block(block.clone()), &root)?;

            // check that the function type matches the return type
            if let Some(return_type) = &f.return_type_opt {
                self.check_types(
                    &mut self.current_symbol_table(),
                    &return_type,
                    &mut function_type,
                )?;
            }

            // self.exit_scope();
        }

        log_trace!(
            self.logger,
            "analysis of function `{full_path}({:?}) -> {}` complete",
            f.param_strings(),
            f.return_type_opt
                .clone()
                .unwrap_or(Box::new(Type::UNIT_TYPE))
        );

        self.exit_scope();

        Ok(())
    }

    fn analyse_function_params(
        &mut self,
        param_type: Type,
        param_path: TypePath,
        param: &FunctionOrMethodParam,
    ) -> Result<(), SemanticErrorKind> {
        Ok(match param_type {
            Type::Generic(GenericParam { name, .. }) => match self.lookup(&name.to_type_path()) {
                Some(_) => (),
                None => {
                    return Err(SemanticErrorKind::UndeclaredGenericParams {
                        found: name.to_backtick_string(),
                    })
                }
            },

            Type::FunctionPtr(fp) => {
                self.insert(
                    param_path.clone(),
                    Symbol::Function {
                        path: param_path.clone(),
                        function: Rc::new(FunctionItem {
                            attributes_opt: None,
                            visibility: Visibility::Private,
                            kw_func: Keyword::Anonymous,
                            function_name: Identifier::from(""),
                            generic_params_opt: None,
                            params_opt: fp.params_opt,
                            return_type_opt: fp.return_type_opt,
                            block_opt: None,
                            span: Span::default(),
                        }),
                    },
                )?;
            }

            Type::UserDefined(tp) => match self.lookup(&tp).cloned() {
                Some(sym) => {
                    self.insert(param_path, sym)?;
                }
                None => {
                    return Err(SemanticErrorKind::UndefinedType { name: tp.type_name });
                }
            },

            Type::Reference { inner_type, .. } => {
                self.analyse_function_params(*inner_type, param_path, param)?
            }

            ty => self.insert(
                param_path,
                Symbol::Variable {
                    name: param.param_name(),
                    var_type: ty,
                },
            )?,
        })
    }

    // TODO: test re-export statements (`pub use ...`);

    /// Analyse an import declaration, resolving and inserting symbols from the imported
    /// modules into the current scope.
    fn analyse_import(
        &mut self,
        import_decl: &ImportDecl,
        lib_root: &Identifier,
    ) -> Result<(), SemanticErrorKind> {
        let path_segments = import_decl.import_tree.path_segments.clone();

        let import_paths = get_type_paths(path_segments);

        for import_path in import_paths.iter() {
            let import_root =
                if let Some(ids) = import_path.associated_type_path_prefix_opt.as_ref() {
                    if !ids.is_empty() {
                        ids.first().cloned().unwrap()
                    } else {
                        import_path.type_name.clone()
                    }
                } else {
                    lib_root.clone()
                };

            // bring external libraries into scope
            if let Some(lib_contents) = self.lib_registry.get(&import_root).cloned() {
                for Module { table, .. } in lib_contents {
                    for (item_path, symbol) in table.iter() {
                        let item_path =
                            if let Some(ids) = &item_path.associated_type_path_prefix_opt {
                                if ids.first().is_some_and(|id| id == &Identifier::from("lib")) {
                                    item_path.clone().strip_prefix()
                                } else {
                                    item_path.clone()
                                }
                            } else {
                                item_path.clone()
                            };

                        match &symbol {
                            Symbol::Struct {
                                path,
                                associated_items_inherent,
                                associated_items_trait,
                                ..
                            }
                            | Symbol::TupleStruct {
                                path,
                                associated_items_inherent,
                                associated_items_trait,
                                ..
                            }
                            | Symbol::Enum {
                                path,
                                associated_items_inherent,
                                associated_items_trait,
                                ..
                            } => {
                                for scope in self.scope_stack.iter().rev() {
                                    for type_path in scope.symbols.keys() {
                                        match scope.scope_kind {
                                            ScopeKind::Module { .. }
                                            | ScopeKind::ProgramRoot
                                            | ScopeKind::Public => (),
                                            _ => {
                                                if type_path.type_name == path.type_name {
                                                    return Err(SemanticErrorKind::ImportClash {
                                                        type_name: path.type_name.clone(),
                                                        module_name: type_path.type_name.clone(),
                                                    });
                                                }
                                            }
                                        }
                                    }
                                }

                                if let Some(Scope { symbols, .. }) = self.scope_stack.last() {
                                    if !symbols.contains_key(&item_path.type_name.to_type_path()) {
                                        self.insert(
                                            item_path.type_name.to_type_path(),
                                            symbol.clone(),
                                        )?;
                                    }
                                }

                                for item in associated_items_inherent {
                                    match item {
                                        InherentImplItem::ConstantDecl(cd) => self.insert(
                                            item_path
                                                .type_name
                                                .to_type_path()
                                                .clone_append(cd.constant_name.to_type_path()),
                                            Symbol::Constant {
                                                path: path
                                                    .clone_append(cd.constant_name.to_type_path()),
                                                visibility: cd.visibility.clone(),
                                                constant_name: cd.constant_name.clone(),
                                                constant_type: *cd.constant_type.clone(),
                                            },
                                        )?,
                                        InherentImplItem::FunctionItem(fi) => {
                                            let function_item = Rc::new(fi.clone());

                                            self.insert(
                                                item_path.type_name.to_type_path().clone_append(
                                                    function_item.function_name.to_type_path(),
                                                ),
                                                Symbol::Function {
                                                    path: path.clone_append(
                                                        function_item.function_name.to_type_path(),
                                                    ),
                                                    function: function_item,
                                                },
                                            )?
                                        }
                                    }
                                }

                                for item in associated_items_trait {
                                    match item {
                                        TraitImplItem::AliasDecl(ad) => self.insert(
                                            item_path
                                                .type_name
                                                .to_type_path()
                                                .clone_append(ad.alias_name.to_type_path()),
                                            Symbol::Alias {
                                                path: path
                                                    .clone_append(ad.alias_name.to_type_path()),
                                                visibility: ad.visibility.clone(),
                                                alias_name: ad.alias_name.clone(),
                                                original_type_opt: ad.original_type_opt.clone(),
                                            },
                                        )?,
                                        TraitImplItem::ConstantDecl(cd) => self.insert(
                                            item_path
                                                .type_name
                                                .to_type_path()
                                                .clone_append(cd.constant_name.to_type_path()),
                                            Symbol::Constant {
                                                path: path
                                                    .clone_append(cd.constant_name.to_type_path()),
                                                visibility: cd.visibility.clone(),
                                                constant_name: cd.constant_name.clone(),
                                                constant_type: *cd.constant_type.clone(),
                                            },
                                        )?,
                                        TraitImplItem::FunctionItem(fi) => {
                                            let function_item = Rc::new(fi.clone());

                                            self.insert(
                                                item_path.type_name.to_type_path().clone_append(
                                                    function_item.function_name.to_type_path(),
                                                ),
                                                Symbol::Function {
                                                    path: {
                                                        path.clone_append(
                                                            fi.function_name.to_type_path(),
                                                        )
                                                    },
                                                    function: function_item,
                                                },
                                            )?
                                        }
                                    }
                                }
                            }

                            Symbol::Module { symbols, .. } => {
                                for (path, sym) in symbols {
                                    if !table.contains_key(&path) {
                                        self.insert(path.type_name.to_type_path(), sym.clone())?;
                                        // TODO: also import associated items for structs and enums
                                    }
                                }
                            }

                            _ => {
                                if let Some(Scope { symbols, .. }) = self.scope_stack.last() {
                                    if !symbols.contains_key(&item_path.clone().strip_prefix()) {
                                        let item_path = item_path.clone().strip_prefix();
                                        println!("import item: {item_path}");
                                        self.insert(item_path, symbol.clone())?;
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                return Err(SemanticErrorKind::UndefinedLibrary { name: import_root });
            }
        }

        Ok(())
    }

    fn analyse_trait_impl_items(
        &mut self,
        trait_def: &TraitDef,
        trait_impl_def: &TraitImplDef,
        implementing_type_path: &TypePath,
        trait_impl_path: TypePath,
        function_symbols: &mut HashMap<TypePath, Symbol>,
    ) -> Result<(), SemanticErrorKind> {
        Ok(
            if let Some(impl_items) = &trait_impl_def.associated_items_opt {
                let mut object_symbol = if let Some(s) = self.lookup(implementing_type_path) {
                    s.to_owned()
                } else {
                    return Err(SemanticErrorKind::MissingItem {
                        expected: "struct or enum symbol".to_string(),
                    });
                };

                for impl_item in impl_items.iter() {
                    if let Some(def_items) = &trait_def.trait_items_opt {
                        let def_item_names = def_items
                            .iter()
                            .map(|item| item.item_name())
                            .collect::<Vec<_>>();

                        if !def_item_names.contains(&impl_item.item_name()) {
                            self.log_error(
                                SemanticErrorKind::UndeclaredTraitItem {
                                    item_name: impl_item.item_name(),
                                    implemented_trait_path: trait_impl_def
                                        .implemented_trait_path
                                        .clone(),
                                },
                                &impl_item.span(),
                            )
                        }

                        for def_item in def_items.iter() {
                            match self.trait_items_match(impl_item, def_item) {
                                Ok(true) => match impl_item {
                                    TraitImplItem::AliasDecl(ad) => self.analyse_stmt(
                                        &Statement::Item(Item::AliasDecl(ad.clone())),
                                        trait_impl_path.clone(),
                                    )?,
                                    TraitImplItem::ConstantDecl(cd) => self.analyse_stmt(
                                        &Statement::Item(Item::ConstantDecl(cd.clone())),
                                        trait_impl_path.clone(),
                                    )?,
                                    TraitImplItem::FunctionItem(fi) => {
                                        let function_item = Rc::new(fi.clone());

                                        let function_impl_path = trait_impl_path.clone_append(
                                            function_item.function_name.to_type_path(),
                                        );

                                        if !function_item.block_opt.clone().is_some_and(|block| {
                                            block
                                                .statements_opt
                                                .is_some_and(|stmts| !stmts.is_empty())
                                        }) {
                                            match self
                                                .lookup(&trait_impl_def.implemented_trait_path)
                                                .cloned()
                                            {
                                                Some(Symbol::Trait { trait_def, .. }) => {
                                                    if let Some(def_items) =
                                                        &trait_def.trait_items_opt
                                                    {
                                                        for def_item in def_items {
                                                            if let TraitDefItem::FunctionItem(
                                                                function,
                                                            ) = def_item
                                                            {
                                                                if function.function_name
                                                                    == function_item.function_name
                                                                {
                                                                    if function
                                                            .clone()
                                                            .block_opt
                                                            .is_some_and(|block| {
                                                                block.statements_opt.is_some_and(
                                                                    |stmts| !stmts.is_empty(),
                                                                )
                                                            })
                                                        {
                                                            log_trace!(self.logger, "switching to default function implementation in trait definition: `{}` …", trait_impl_def.implemented_trait_path);

                                                            function_symbols.insert(
                                                                function_impl_path.clone(),
                                                                Symbol::Function {
                                                                    path: function_impl_path,
                                                                    function: Rc::new(function.clone()),
                                                                },
                                                            );

                                                            match self.analyse_function_def(
                                                                &function,
                                                                &trait_impl_path,
                                                                false,
                                                                true,
                                                            ) {
                                                                Ok(_) => (),
                                                                Err(err) => self.log_error(
                                                                    err,
                                                                    &trait_impl_def.span,
                                                                ),
                                                            }

                                                            object_symbol.add_associated_items(
                                                                None,
                                                                Some(TraitImplItem::FunctionItem(
                                                                    function.clone(),
                                                                )),
                                                            )?;

                                                            return Ok(());
                                                        }
                                                                }
                                                            }
                                                        }
                                                    }

                                                    return Err(SemanticErrorKind::MissingTraitFunctionImpl {
                                            func_name: fi.clone().function_name,
                                        });
                                                }

                                                Some(sym) => {
                                                    return Err(
                                                        SemanticErrorKind::UnexpectedSymbol {
                                                            name: trait_impl_def
                                                                .implemented_trait_path
                                                                .to_identifier(),
                                                            expected: "trait".to_string(),
                                                            found: sym.to_backtick_string(),
                                                        },
                                                    )
                                                }

                                                None => {
                                                    return Err(SemanticErrorKind::MissingItem {
                                                        expected: "trait".to_string(),
                                                    })
                                                }
                                            }
                                        }

                                        function_symbols.insert(
                                            function_impl_path.clone(),
                                            Symbol::Function {
                                                path: function_impl_path,
                                                function: function_item,
                                            },
                                        );

                                        match self.analyse_function_def(
                                            fi,
                                            &trait_impl_path,
                                            true,
                                            true,
                                        ) {
                                            Ok(_) => (),
                                            Err(err) => self.log_error(err, &trait_impl_def.span),
                                        }
                                    }
                                },
                                Ok(false) => (),
                                Err(err) => return Err(err),
                            }
                        }
                    }

                    object_symbol.add_associated_items(None, Some(impl_item.clone()))?;
                }
            },
        )
    }

    pub(crate) fn trait_items_match(
        &mut self,
        trait_impl_item: &TraitImplItem,
        trait_def_item: &TraitDefItem,
    ) -> Result<bool, SemanticErrorKind> {
        match (trait_impl_item, trait_def_item) {
            (TraitImplItem::AliasDecl(ad_impl), TraitDefItem::AliasDecl(ad_def)) => {
                if ad_impl.alias_name == ad_def.alias_name {
                    if ad_impl.attributes_opt != ad_def.attributes_opt {
                        return Err(SemanticErrorKind::AttributesMismatch {
                            item_name: ad_impl.alias_name.clone(),
                            expected: format!("{:?}", ad_def.attributes_opt),
                            found: format!("{:?}", ad_impl.attributes_opt),
                        });
                    }

                    if ad_impl.visibility != ad_def.visibility {
                        return Err(SemanticErrorKind::VisibilityMismatch {
                            item_name: ad_impl.alias_name.clone(),
                            expected: ad_def.visibility.to_backtick_string(),
                            found: ad_impl.visibility.to_backtick_string(),
                        });
                    }

                    Ok(true)
                } else {
                    Ok(false)
                }
            }

            (TraitImplItem::AliasDecl(_), _) => Ok(false),

            (TraitImplItem::ConstantDecl(cd_impl), TraitDefItem::ConstantDecl(cd_def)) => {
                if cd_impl.constant_name == cd_def.constant_name {
                    if cd_impl.attributes_opt != cd_def.attributes_opt {
                        return Err(SemanticErrorKind::AttributesMismatch {
                            item_name: cd_impl.constant_name.clone(),
                            expected: format!("{:?}", cd_def.attributes_opt),
                            found: format!("{:?}", cd_impl.attributes_opt),
                        });
                    }

                    if cd_impl.visibility != cd_def.visibility {
                        return Err(SemanticErrorKind::VisibilityMismatch {
                            item_name: cd_impl.constant_name.clone(),
                            expected: cd_def.visibility.to_backtick_string(),
                            found: cd_impl.visibility.to_backtick_string(),
                        });
                    }

                    if cd_impl.constant_type != cd_def.constant_type {
                        return Err(SemanticErrorKind::TypeMismatchConst {
                            constant_name: cd_impl.constant_name.clone(),
                            expected: *cd_def.constant_type.clone(),
                            found: *cd_impl.constant_type.clone(),
                        });
                    }

                    Ok(true)
                } else {
                    Ok(false)
                }
            }
            (TraitImplItem::ConstantDecl(_), _) => Ok(false),
            (TraitImplItem::FunctionItem(fi_impl), TraitDefItem::FunctionItem(fi_def)) => {
                if fi_impl.function_name == fi_def.function_name {
                    if fi_impl.attributes_opt != fi_def.attributes_opt {
                        return Err(SemanticErrorKind::AttributesMismatch {
                            item_name: fi_impl.function_name.clone(),
                            expected: format!("{:?}", fi_def.attributes_opt),
                            found: format!("{:?}", fi_impl.attributes_opt),
                        });
                    }

                    if fi_impl.visibility != fi_def.visibility {
                        return Err(SemanticErrorKind::VisibilityMismatch {
                            item_name: fi_impl.function_name.clone(),
                            expected: fi_def.visibility.to_backtick_string(),
                            found: fi_impl.visibility.to_backtick_string(),
                        });
                    }

                    if let Some(generics_impl) = &fi_impl.generic_params_opt {
                        if let Some(generics_def) = &fi_def.generic_params_opt {
                            if generics_impl.params.len() != generics_def.params.len() {
                                return Err(SemanticErrorKind::GenericParamsCountMismatch {
                                    item_name: fi_impl.function_name.clone(),
                                    expected: generics_def.params.len(),
                                    found: generics_impl.params.len(),
                                });
                            }
                        } else {
                            return Err(SemanticErrorKind::GenericParamsCountMismatch {
                                item_name: fi_impl.function_name.clone(),
                                expected: 0,
                                found: generics_impl.params.len(),
                            });
                        }
                    } else {
                        if let Some(generics_def) = &fi_def.generic_params_opt {
                            return Err(SemanticErrorKind::GenericParamsCountMismatch {
                                item_name: fi_impl.function_name.clone(),
                                expected: generics_def.params.len(),
                                found: 0,
                            });
                        }
                    }

                    if let Some(params_impl) = &fi_impl.params_opt {
                        if let Some(params_def) = &fi_def.params_opt {
                            for (impl_param, def_param) in params_impl.iter().zip(params_def) {
                                match (impl_param, def_param) {
                                    (
                                        FunctionOrMethodParam::FunctionParam(func_param_impl),
                                        FunctionOrMethodParam::FunctionParam(func_param_def),
                                    ) => {
                                        if func_param_impl.param_type != func_param_def.param_type {
                                            return Err(SemanticErrorKind::TypeMismatchParam {
                                                function_name: fi_impl.function_name.clone(),
                                                expected: *func_param_def.param_type.clone(),
                                                found: *func_param_impl.param_type.clone(),
                                            });
                                        }
                                    }
                                    (
                                        FunctionOrMethodParam::FunctionParam(_),
                                        FunctionOrMethodParam::MethodParam(_),
                                    )
                                    | (
                                        FunctionOrMethodParam::MethodParam(_),
                                        FunctionOrMethodParam::FunctionParam(_),
                                    ) => {
                                        return Err(SemanticErrorKind::TypeMismatchParam {
                                            function_name: fi_impl.function_name.clone(),
                                            expected: def_param.param_type(),
                                            found: impl_param.param_type(),
                                        })
                                    }
                                    (
                                        FunctionOrMethodParam::MethodParam(self_param_impl),
                                        FunctionOrMethodParam::MethodParam(self_param_def),
                                    ) => {
                                        if self_param_impl.reference_op_opt
                                            != self_param_def.reference_op_opt
                                        {
                                            return Err(SemanticErrorKind::TypeMismatchSelfParam {
                                                expected: self_param_def.to_backtick_string(),
                                                found: self_param_impl.to_backtick_string(),
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if let Some(params_def) = &fi_def.params_opt {
                            return Err(SemanticErrorKind::ParamCountMismatch {
                                function_name: fi_impl.function_name.clone(),
                                expected: params_def.len(),
                                found: 0,
                            });
                        }
                    }

                    if fi_impl.return_type_opt != fi_def.return_type_opt {
                        return Err(SemanticErrorKind::TypeMismatchReturnType {
                            expected: *fi_def
                                .return_type_opt
                                .clone()
                                .unwrap_or(Box::new(Type::UNIT_TYPE)),
                            found: *fi_impl
                                .return_type_opt
                                .clone()
                                .unwrap_or(Box::new(Type::UNIT_TYPE)),
                        });
                    }

                    Ok(true)
                } else {
                    Ok(false)
                }
            }
            (TraitImplItem::FunctionItem(_), _) => Ok(false),
        }
    }

    fn try_update_current_scope(&mut self, expected: &ScopeKind, new_scope_kind: ScopeKind) {
        if let Some(Scope { scope_kind, .. }) = self.scope_stack.last() {
            if scope_kind == expected {
                self.enter_scope(new_scope_kind)
            }
        }
    }

    /// Check if two types match. Returns `Ok` if they are compatible or can be unified, or
    /// an `Err` if there is a type mismatch.
    fn check_types(
        &mut self,
        symbol_table: &mut SymbolTable,
        expected_type: &Type,
        matched_type: &mut Type,
    ) -> Result<(), SemanticErrorKind> {
        log_trace!(
            self.logger,
            "checking compatibility between types `{matched_type}` and expected type `{expected_type}` …"
        );

        match (expected_type.clone(), matched_type.clone()) {
            // if both types are the same, they are already unified
            _ if expected_type == matched_type => (),

            (Type::InferredType(_), _) => return Err(SemanticErrorKind::UnexpectedInferredType),

            // TODO: custom error
            (Type::SelfType { .. }, _) => {
                return Err(SemanticErrorKind::UnexpectedType {
                    expected: "non-`Self` type".to_string(),
                    found: expected_type.clone(),
                })
            }

            (Type::UserDefined(_), Type::SelfType { .. }) => {
                log_trace!(
                    self.logger,
                    "attempting to unify `Self` type with expected type `{expected_type}` …"
                );
                unify_self_type(matched_type, expected_type.clone());
            }

            (ty, Type::SelfType { .. }) => {
                return Err(SemanticErrorKind::UnexpectedType {
                    expected: "user-defined type".to_string(),
                    found: ty,
                })
            }

            // if one is a concrete or generic type and the other is inferred, resolve the inference
            (concrete_or_generic, Type::InferredType(_)) => {
                log_trace!(self.logger, "attempting to unify inferred type with expected type `{concrete_or_generic}` …");
                unify_inferred_type(matched_type, concrete_or_generic);
            }

            (
                Type::Generic(GenericParam {
                    name: name_a,
                    type_bound_opt: bound_a,
                }),
                Type::Generic(GenericParam {
                    name: name_b,
                    type_bound_opt: bound_b,
                }),
            ) => {
                if name_a == name_b {
                    match (bound_a, bound_b) {
                        (None, None) => (),
                        (None, Some(_)) => {
                            return Err(SemanticErrorKind::TypeBoundCountMismatch {
                                expected: 0,
                                found: 1,
                            })
                        }
                        (Some(_), None) => {
                            return Err(SemanticErrorKind::TypeBoundCountMismatch {
                                expected: 1,
                                found: 0,
                            })
                        }
                        (Some(a), Some(b)) => {
                            if a != b {
                                return Err(SemanticErrorKind::TypeMismatchTypeBound {
                                    expected: a.to_identifier(),
                                    found: b.to_identifier(),
                                });
                            }
                        }
                    }
                } else {
                    return Err(SemanticErrorKind::TypeMismatchUnification {
                        expected: expected_type.to_identifier(),
                        found: matched_type.to_identifier(),
                    });
                }
            }

            // TODO: custom error
            (
                Type::Generic(GenericParam {
                    name,
                    type_bound_opt,
                }),
                _,
            ) => {
                return Err(SemanticErrorKind::UnexpectedType {
                    expected: "non-generic type".to_string(),
                    found: Type::Generic(GenericParam {
                        name,
                        type_bound_opt,
                    }),
                });
            }

            (concrete, Type::Generic { .. }) => {
                self.unify_generic_with_concrete(symbol_table, matched_type, &concrete)?;
            }

            (Type::GroupedType(grouped), matched) => {
                if *grouped != matched {
                    return Err(SemanticErrorKind::TypeMismatchInnerType {
                        context: "grouped".to_string(),
                        expected: grouped.to_backtick_string(),
                        found: matched,
                    });
                }
            }

            (
                Type::I32
                | Type::I64
                | Type::U8
                | Type::U16
                | Type::U32
                | Type::U64
                | Type::U256
                | Type::U512
                | Type::F32
                | Type::F64,
                Type::I32
                | Type::I64
                | Type::U8
                | Type::U16
                | Type::U32
                | Type::U64
                | Type::U256
                | Type::U512
                | Type::F32
                | Type::F64,
            ) => {
                // log_trace!(self.logger, "attempting to unify numeric type `{matched_type}` with expected type `{expected_type}` …");

                unify_numeric_types(expected_type, matched_type)?;
            }

            (
                Type::Array {
                    element_type: elem_type_a,
                    num_elements: num_elems_a,
                },
                Type::Array {
                    element_type: elem_type_b,
                    num_elements: num_elems_b,
                },
            ) => {
                if elem_type_a != elem_type_b {
                    return Err(SemanticErrorKind::TypeMismatchArrayElems {
                        expected: elem_type_a.to_backtick_string(),
                        found: *elem_type_b,
                    });
                }

                if num_elems_a != num_elems_b {
                    return Err(SemanticErrorKind::ArrayLengthMismatch {
                        expected: num_elems_a.into(),
                        found: num_elems_b.into(),
                    });
                }
            }

            (Type::Tuple(elem_types_a), Type::Tuple(elem_types_b)) => {
                if elem_types_a.len() != elem_types_b.len() {
                    return Err(SemanticErrorKind::TupleLengthMismatch {
                        expected: elem_types_a.len(),
                        found: elem_types_b.len(),
                    });
                }

                for (a, b) in elem_types_a.into_iter().zip(elem_types_b) {
                    if a != b {
                        return Err(SemanticErrorKind::TypeMismatchTupleElems {
                            expected: a,
                            found: b,
                        });
                    }
                }
            }

            (Type::FunctionPtr(ptr_a), Type::FunctionPtr(ptr_b)) => {
                match (&ptr_a.params_opt, ptr_b.params_opt) {
                    (None, None) => (),
                    (None, Some(params_b)) => {
                        return Err(SemanticErrorKind::ParamCountMismatch {
                            function_name: Identifier::from(""),
                            expected: 0,
                            found: params_b.len(),
                        })
                    }
                    (Some(params_a), None) => {
                        return Err(SemanticErrorKind::ParamCountMismatch {
                            function_name: Identifier::from(""),
                            expected: params_a.len(),
                            found: 0,
                        })
                    }
                    (Some(params_a), Some(params_b)) => {
                        if params_a.len() != params_b.len() {
                            return Err(SemanticErrorKind::ParamCountMismatch {
                                function_name: Identifier::from(""),
                                expected: params_a.len(),
                                found: params_b.len(),
                            });
                        }

                        for (param_a, param_b) in params_a.iter().zip(params_b) {
                            match (param_a, param_b) {
                                (
                                    FunctionOrMethodParam::FunctionParam(func_param_a),
                                    FunctionOrMethodParam::FunctionParam(func_param_b),
                                ) => {
                                    if *func_param_a != func_param_b {
                                        return Err(SemanticErrorKind::TypeMismatchParam {
                                            function_name: Identifier::from(""),
                                            expected: *func_param_a.param_type.clone(),
                                            found: *func_param_b.param_type,
                                        });
                                    }
                                }
                                (
                                    FunctionOrMethodParam::FunctionParam(param_a),
                                    FunctionOrMethodParam::MethodParam(sp),
                                ) => {
                                    return Err(SemanticErrorKind::UnexpectedParam {
                                        expected: param_a.param_type.to_backtick_string(),
                                        found: sp.to_identifier(),
                                    })
                                }
                                (
                                    FunctionOrMethodParam::MethodParam(param_a),
                                    FunctionOrMethodParam::FunctionParam(param_b),
                                ) => {
                                    return Err(SemanticErrorKind::UnexpectedParam {
                                        expected: param_a.to_backtick_string(),
                                        found: param_b.param_type.to_identifier(),
                                    })
                                }
                                (
                                    FunctionOrMethodParam::MethodParam(self_param_a),
                                    FunctionOrMethodParam::MethodParam(self_param_b),
                                ) => {
                                    match (
                                        &self_param_a.reference_op_opt,
                                        &self_param_b.reference_op_opt,
                                    ) {
                                        (None, None) => (),
                                        (None, Some(_)) | (Some(_), None) => {
                                            return Err(SemanticErrorKind::TypeMismatchSelfParam {
                                                expected: self_param_a.to_backtick_string(),
                                                found: self_param_b.to_backtick_string(),
                                            });
                                        }
                                        (Some(ref_op_a), Some(ref_op_b)) => {
                                            if ref_op_a != ref_op_b {
                                                return Err(
                                                    SemanticErrorKind::TypeMismatchSelfParam {
                                                        expected: self_param_a.to_backtick_string(),
                                                        found: self_param_b.to_backtick_string(),
                                                    },
                                                );
                                            }
                                        }
                                    }

                                    match (self_param_a.kw_self, self_param_b.kw_self) {
                                        (Keyword::SelfKeyword, Keyword::SelfKeyword) => (),
                                        (_, kw) => {
                                            return Err(SemanticErrorKind::UnexpectedKeyword {
                                                expected: Keyword::SelfKeyword.to_string(),
                                                found: kw,
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                match (ptr_a.return_type_opt, ptr_b.return_type_opt) {
                    (None, None) => (),
                    (None, Some(ty)) => {
                        if let Type::UnitType(UnitType) = *ty {
                            ()
                        } else {
                            return Err(SemanticErrorKind::UnexpectedReturnType { found: *ty });
                        }
                    }
                    (Some(ty), None) => {
                        if let Type::UnitType(UnitType) = *ty {
                            ()
                        } else {
                            return Err(SemanticErrorKind::MissingReturnType { expected: *ty });
                        }
                    }
                    (Some(return_type_a), Some(return_type_b)) => {
                        if return_type_a != return_type_b {
                            return Err(SemanticErrorKind::TypeMismatchReturnType {
                                expected: *return_type_a,
                                found: *return_type_b,
                            });
                        }
                    }
                }
            }

            (
                Type::Reference {
                    reference_op: ref_op_a,
                    inner_type: inner_type_a,
                },
                Type::Reference {
                    reference_op: ref_op_b,
                    inner_type: inner_type_b,
                },
            ) => {
                if ref_op_a != ref_op_b {
                    return Err(SemanticErrorKind::RefOperatorMismatch {
                        expected: ref_op_a,
                        found: ref_op_b,
                    });
                }

                if inner_type_a != inner_type_b {
                    return Err(SemanticErrorKind::TypeMismatchInnerType {
                        context: "reference".to_string(),
                        expected: format!("`{ref_op_a}{inner_type_a}`"),
                        found: *inner_type_b,
                    });
                }
            }

            (
                Type::Vec {
                    element_type: elem_type_a,
                },
                Type::Vec {
                    element_type: elem_type_b,
                },
            ) => {
                if elem_type_a != elem_type_b {
                    return Err(SemanticErrorKind::TypeMismatchArrayElems {
                        expected: elem_type_a.to_backtick_string(),
                        found: *elem_type_b,
                    });
                }
            }

            (
                Type::Mapping {
                    key_type: key_type_a,
                    value_type: val_type_a,
                },
                Type::Mapping {
                    key_type: key_type_b,
                    value_type: val_type_b,
                },
            ) => {
                if key_type_a != key_type_b {
                    return Err(SemanticErrorKind::TypeMismatchMappingKey {
                        expected: *key_type_a,
                        found: *key_type_b,
                    });
                }

                if val_type_a != val_type_b {
                    return Err(SemanticErrorKind::TypeMismatchMappingValue {
                        expected: *val_type_a,
                        found: *val_type_b,
                    });
                }
            }

            (
                Type::Option {
                    inner_type: inner_type_a,
                },
                Type::Option {
                    inner_type: inner_type_b,
                },
            ) => {
                if inner_type_a != inner_type_b {
                    return Err(SemanticErrorKind::TypeMismatchInnerType {
                        context: "`Some` variant in `Option<T>`".to_string(),
                        expected: inner_type_a.to_backtick_string(),
                        found: *inner_type_b,
                    });
                }
            }

            (Type::Result { .. }, Type::Result { .. }) => {
                log_trace!(self.logger, "attempting to unify `Result<T, E>` types …");
                unify_result_types(matched_type, &expected_type)?;
            }

            (Type::UserDefined(type_path_a), Type::UserDefined(type_path_b)) => {
                if type_path_a != type_path_b {
                    return Err(SemanticErrorKind::TypeMismatchUserDefined {
                        expected: type_path_a.to_identifier(),
                        found: type_path_b.to_identifier(),
                    });
                }
            }

            _ => {
                return Err(SemanticErrorKind::TypeMismatchUnification {
                    expected: expected_type.to_identifier(),
                    found: matched_type.to_identifier(),
                })
            }
        }

        log_trace!(self.logger, "type check successful");
        Ok(())
    }

    fn unify_generic_with_concrete(
        &mut self,
        symbol_table: &mut SymbolTable,
        generic_type: &mut Type,
        concrete_type: &Type,
    ) -> Result<(), SemanticErrorKind> {
        match generic_type {
            Type::Generic(GenericParam {
                name,
                type_bound_opt,
            }) => {
                // check if the concrete type satisfies the bounds of the generic type
                if let Some(bound_path) = type_bound_opt {
                    let bound_trait = self.lookup_trait(&bound_path)?;

                    // check if the concrete type implements the required trait
                    if !self.type_satisfies_bound(concrete_type, &bound_trait) {
                        return Err(SemanticErrorKind::TypeBoundNotSatisfied {
                            generic_name: name.clone(),
                            expected_bound: bound_path.to_identifier(),
                            found_type: concrete_type.clone(),
                        });
                    }
                }

                // if bounds are satisfied, perform the substitution
                self.substitute_generic_with_concrete(symbol_table, name, concrete_type);
                Ok(())
            }

            _ => self.check_types(symbol_table, concrete_type, generic_type),
        }
    }

    /// Add a trait implementation to the type table.
    fn add_trait_implementation(&mut self, concrete_type: TypePath, trait_impl: TraitImplDef) {
        self.type_table
            .entry(concrete_type)
            .or_insert_with(Vec::new)
            .push(trait_impl);
    }

    /// Lookup logic to find the trait definition in the current scope
    fn lookup_trait(&mut self, bound_path: &TypePath) -> Result<TraitDef, SemanticErrorKind> {
        if let Some(Symbol::Trait { trait_def, .. }) = self.lookup(bound_path).cloned() {
            Ok(Rc::into_inner(trait_def).unwrap())
        } else {
            Err(SemanticErrorKind::UndefinedSymbol {
                name: bound_path.type_name.to_string(),
            })
        }
    }

    /// Replace all occurrences of `generic_name` with `concrete_type`.
    fn substitute_generic_with_concrete(
        &mut self,
        symbol_table: &mut SymbolTable,
        generic_name: &Identifier,
        concrete_type: &Type,
    ) {
        log_trace!(
            self.logger,
            "substituting generic `{generic_name}` with concrete type `{concrete_type}` …"
        );

        let scope_stack = &self.scope_stack;

        // iterate through the scope stack and substitute generics in all types.
        for scope in scope_stack.to_owned().iter_mut() {
            for symbol in scope.symbols.values_mut() {
                self.substitute_in_symbol(symbol, symbol_table, generic_name, concrete_type);
            }
        }
    }

    fn substitute_in_symbol(
        &mut self,
        symbol: &mut Symbol,
        symbol_table: &mut SymbolTable,
        generic_name: &Identifier,
        concrete_type: &Type,
    ) {
        log_trace!(
            self.logger,
            "substituting generic `{generic_name}` with concrete type `{concrete_type}` in symbol `{}` …",
            symbol.type_path()
        );

        // apply substitution to each symbol within the current scope by delegating to specific
        // substitution functions
        match symbol {
            Symbol::Variable { var_type, .. } => {
                self.substitute_in_type(var_type, symbol_table, generic_name, concrete_type);
            }
            Symbol::Struct { struct_def, .. } => {
                self.substitute_in_struct(
                    Rc::get_mut(struct_def).unwrap(),
                    symbol_table,
                    generic_name,
                    concrete_type,
                );
            }
            Symbol::TupleStruct {
                tuple_struct_def, ..
            } => {
                self.substitute_in_tuple_struct(
                    Rc::get_mut(tuple_struct_def).unwrap(),
                    symbol_table,
                    generic_name,
                    concrete_type,
                );
            }
            Symbol::Enum { enum_def, .. } => {
                self.substitute_in_enum(
                    Rc::get_mut(enum_def).unwrap(),
                    symbol_table,
                    generic_name,
                    concrete_type,
                );
            }
            Symbol::Trait { trait_def, .. } => self.substitute_in_trait(
                Rc::get_mut(trait_def).unwrap(),
                symbol_table,
                generic_name,
                concrete_type,
            ),
            Symbol::Alias {
                original_type_opt, ..
            } => {
                self.substitute_opt_type(
                    original_type_opt,
                    symbol_table,
                    generic_name,
                    concrete_type,
                );
            }
            Symbol::Constant { constant_type, .. } => {
                self.substitute_in_type(constant_type, symbol_table, generic_name, concrete_type);
            }
            Symbol::Function { function, .. } => {
                self.substitute_in_function(
                    Rc::get_mut(function).unwrap(),
                    symbol_table,
                    generic_name,
                    concrete_type,
                );
            }
            Symbol::Module { module, .. } => {
                self.substitute_in_module(module, symbol_table, generic_name, concrete_type)
            }
        }
    }

    fn substitute_in_type(
        &mut self,
        ty: &mut Type,
        symbol_table: &mut SymbolTable,
        generic_name: &Identifier,
        concrete_type: &Type,
    ) {
        // perform substitution for types
        // if we encounter a generic type param, replace it with the concrete type
        match ty {
            Type::Generic(GenericParam { name, .. }) if name == generic_name => {
                *ty = concrete_type.clone();
            }
            Type::GroupedType(inner_type) => {
                self.substitute_in_type(inner_type, symbol_table, generic_name, concrete_type)
            }
            Type::Array { element_type, .. } => {
                self.substitute_in_type(element_type, symbol_table, generic_name, concrete_type);
            }
            Type::Tuple(element_types) => {
                for elem_type in element_types {
                    self.substitute_in_type(elem_type, symbol_table, generic_name, concrete_type);
                }
            }
            Type::FunctionPtr(ptr) => {
                if let Some(params) = ptr.params_opt.as_mut() {
                    for param in params {
                        match param {
                            FunctionOrMethodParam::FunctionParam(FunctionParam {
                                param_type,
                                ..
                            }) => self.substitute_in_type(
                                param_type,
                                symbol_table,
                                generic_name,
                                concrete_type,
                            ),
                            FunctionOrMethodParam::MethodParam(_) => (),
                        }
                    }
                }

                if let Some(ty) = ptr.return_type_opt.as_mut() {
                    self.substitute_in_type(ty, symbol_table, generic_name, concrete_type);
                }
            }
            Type::Reference { inner_type, .. } => {
                self.substitute_in_type(inner_type, symbol_table, generic_name, concrete_type);
            }
            Type::UserDefined(type_path) => {
                if let Some(sym) = symbol_table.to_owned().get_mut(type_path) {
                    match sym {
                        Symbol::Variable { var_type, .. } => self.substitute_in_type(
                            var_type,
                            symbol_table,
                            generic_name,
                            concrete_type,
                        ),
                        Symbol::Struct { struct_def, .. } => {
                            self.substitute_in_struct(
                                Rc::get_mut(struct_def).unwrap(),
                                symbol_table,
                                generic_name,
                                concrete_type,
                            );
                        }
                        Symbol::TupleStruct {
                            tuple_struct_def, ..
                        } => self.substitute_in_tuple_struct(
                            Rc::get_mut(tuple_struct_def).unwrap(),
                            symbol_table,
                            generic_name,
                            concrete_type,
                        ),
                        Symbol::Enum { enum_def, .. } => {
                            self.substitute_in_enum(
                                Rc::get_mut(enum_def).unwrap(),
                                symbol_table,
                                generic_name,
                                concrete_type,
                            );
                        }
                        Symbol::Trait { trait_def, .. } => {
                            self.substitute_in_trait(
                                Rc::get_mut(trait_def).unwrap(),
                                symbol_table,
                                generic_name,
                                concrete_type,
                            );
                        }
                        Symbol::Alias {
                            original_type_opt, ..
                        } => self.substitute_opt_type(
                            original_type_opt,
                            symbol_table,
                            generic_name,
                            concrete_type,
                        ),
                        Symbol::Constant { constant_type, .. } => self.substitute_in_type(
                            constant_type,
                            symbol_table,
                            generic_name,
                            concrete_type,
                        ),
                        Symbol::Function { function, .. } => self.substitute_in_function(
                            Rc::get_mut(function).unwrap(),
                            symbol_table,
                            generic_name,
                            concrete_type,
                        ),
                        Symbol::Module { module, .. } => self.substitute_in_module(
                            module,
                            symbol_table,
                            generic_name,
                            concrete_type,
                        ),
                    }
                }
            }
            Type::SelfType { .. } => {
                unify_self_type(ty, concrete_type.clone());
            }
            Type::InferredType { .. } => unify_inferred_type(ty, concrete_type.clone()),
            Type::Vec { element_type } => {
                self.substitute_in_type(element_type, symbol_table, generic_name, concrete_type);
            }
            Type::Mapping {
                key_type,
                value_type,
            } => {
                self.substitute_in_type(key_type, symbol_table, generic_name, concrete_type);
                self.substitute_in_type(value_type, symbol_table, generic_name, concrete_type);
            }
            Type::Option { inner_type } => {
                self.substitute_in_type(inner_type, symbol_table, generic_name, concrete_type);
            }
            Type::Result { ok_type, err_type } => {
                self.substitute_in_type(ok_type, symbol_table, generic_name, concrete_type);
                self.substitute_in_type(err_type, symbol_table, generic_name, concrete_type);
            }

            _ => (),
        }
    }

    fn substitute_in_struct(
        &mut self,
        struct_def: &mut StructDef,
        symbol_table: &mut SymbolTable,
        generic_name: &Identifier,
        concrete_type: &Type,
    ) {
        if let Some(fields) = struct_def.fields_opt.as_mut() {
            for StructDefField { field_type, .. } in fields {
                self.substitute_in_type(field_type, symbol_table, generic_name, concrete_type);
            }
        }
    }

    fn substitute_in_tuple_struct(
        &mut self,
        tuple_struct_def: &mut TupleStructDef,
        symbol_table: &mut SymbolTable,
        generic_name: &Identifier,
        concrete_type: &Type,
    ) {
        if let Some(fields) = tuple_struct_def.fields_opt.as_mut() {
            for TupleStructDefField { field_type, .. } in fields {
                self.substitute_in_type(field_type, symbol_table, generic_name, concrete_type);
            }
        }
    }

    fn substitute_in_enum(
        &mut self,
        enum_def: &mut EnumDef,
        symbol_table: &mut SymbolTable,
        generic_name: &Identifier,
        concrete_type: &Type,
    ) {
        for variant in enum_def.variants.iter_mut() {
            match variant.variant_kind.clone() {
                EnumVariantKind::Struct(EnumVariantStruct { mut struct_fields }) => {
                    for StructDefField { field_type, .. } in struct_fields.iter_mut() {
                        self.substitute_in_type(
                            field_type,
                            symbol_table,
                            generic_name,
                            concrete_type,
                        );
                    }
                }
                EnumVariantKind::TupleStruct(EnumVariantTupleStruct { mut element_types }, ..) => {
                    for ty in element_types.iter_mut() {
                        self.substitute_in_type(ty, symbol_table, generic_name, concrete_type);
                    }
                }
                _ => (),
            }
        }
    }

    fn substitute_in_trait(
        &mut self,
        trait_def: &mut TraitDef,
        symbol_table: &mut SymbolTable,
        generic_name: &Identifier,
        concrete_type: &Type,
    ) {
        if let Some(items) = trait_def.trait_items_opt.as_mut() {
            for item in items {
                match item {
                    TraitDefItem::AliasDecl(AliasDecl {
                        original_type_opt, ..
                    }) => {
                        self.substitute_opt_type(
                            original_type_opt,
                            symbol_table,
                            generic_name,
                            concrete_type,
                        );
                    }
                    TraitDefItem::ConstantDecl(ConstantDecl { constant_type, .. }) => self
                        .substitute_in_type(
                            constant_type,
                            symbol_table,
                            generic_name,
                            concrete_type,
                        ),
                    TraitDefItem::FunctionItem(function_item) => self.substitute_in_function(
                        function_item,
                        symbol_table,
                        generic_name,
                        concrete_type,
                    ),
                }
            }
        }
    }

    fn substitute_in_function(
        &mut self,
        function: &mut FunctionItem,
        symbol_table: &mut SymbolTable,
        generic_name: &Identifier,
        concrete_type: &Type,
    ) {
        if let Some(params) = function.params_opt.as_mut() {
            for param in params {
                self.substitute_in_type(
                    &mut param.param_type(),
                    symbol_table,
                    generic_name,
                    concrete_type,
                );
            }
        }

        if let Some(return_type) = function.return_type_opt.as_mut() {
            self.substitute_in_type(return_type, symbol_table, generic_name, concrete_type);
        }
    }

    fn substitute_in_module(
        &mut self,
        module: &mut ModuleItem,
        symbol_table: &mut SymbolTable,
        generic_name: &Identifier,
        concrete_type: &Type,
    ) {
        if let Some(items) = module.items_opt.as_mut() {
            for item in items {
                match item {
                    Item::AliasDecl(AliasDecl {
                        original_type_opt, ..
                    }) => self.substitute_opt_type(
                        original_type_opt,
                        symbol_table,
                        generic_name,
                        concrete_type,
                    ),
                    Item::ConstantDecl(ConstantDecl { constant_type, .. }) => self
                        .substitute_in_type(
                            constant_type,
                            symbol_table,
                            generic_name,
                            concrete_type,
                        ),
                    Item::StaticVarDecl(StaticVarDecl { var_type, .. }) => {
                        self.substitute_in_type(var_type, symbol_table, generic_name, concrete_type)
                    }
                    Item::ModuleItem(module) => {
                        self.substitute_in_module(module, symbol_table, generic_name, concrete_type)
                    }
                    Item::TraitDef(trait_def) => self.substitute_in_trait(
                        trait_def,
                        symbol_table,
                        generic_name,
                        concrete_type,
                    ),
                    Item::EnumDef(enum_def) => {
                        self.substitute_in_enum(
                            enum_def,
                            symbol_table,
                            generic_name,
                            concrete_type,
                        );
                    }
                    Item::StructDef(struct_def) => self.substitute_in_struct(
                        struct_def,
                        symbol_table,
                        generic_name,
                        concrete_type,
                    ),
                    Item::TupleStructDef(tuple_struct_def) => self.substitute_in_tuple_struct(
                        tuple_struct_def,
                        symbol_table,
                        generic_name,
                        concrete_type,
                    ),
                    Item::FunctionItem(function) => self.substitute_in_function(
                        function,
                        symbol_table,
                        generic_name,
                        concrete_type,
                    ),
                    Item::InherentImplDef(InherentImplDef {
                        associated_items_opt,
                        ..
                    }) => {
                        if let Some(assoc_items) = associated_items_opt.as_mut() {
                            for item in assoc_items {
                                match item {
                                    InherentImplItem::ConstantDecl(ConstantDecl {
                                        constant_type,
                                        ..
                                    }) => self.substitute_in_type(
                                        constant_type,
                                        symbol_table,
                                        generic_name,
                                        concrete_type,
                                    ),
                                    InherentImplItem::FunctionItem(function) => self
                                        .substitute_in_function(
                                            function,
                                            symbol_table,
                                            generic_name,
                                            concrete_type,
                                        ),
                                }
                            }
                        }
                    }
                    Item::TraitImplDef(TraitImplDef {
                        associated_items_opt,
                        ..
                    }) => {
                        if let Some(assoc_items) = associated_items_opt.as_mut() {
                            for item in assoc_items {
                                match item {
                                    TraitImplItem::AliasDecl(AliasDecl {
                                        original_type_opt,
                                        ..
                                    }) => self.substitute_opt_type(
                                        original_type_opt,
                                        symbol_table,
                                        generic_name,
                                        concrete_type,
                                    ),
                                    TraitImplItem::ConstantDecl(ConstantDecl {
                                        constant_type,
                                        ..
                                    }) => self.substitute_in_type(
                                        constant_type,
                                        symbol_table,
                                        generic_name,
                                        concrete_type,
                                    ),
                                    TraitImplItem::FunctionItem(function) => self
                                        .substitute_in_function(
                                            function,
                                            symbol_table,
                                            generic_name,
                                            concrete_type,
                                        ),
                                }
                            }
                        }
                    }
                    _ => (),
                }
            }
        }
    }

    fn substitute_opt_type(
        &mut self,
        original_type_opt: &mut Option<Type>,
        symbol_table: &mut SymbolTable,
        generic_name: &Identifier,
        concrete_type: &Type,
    ) {
        if let Some(ty) = original_type_opt {
            self.substitute_in_type(ty, symbol_table, generic_name, concrete_type);
        }
    }

    /// Checks if a given type satisfies a specific trait bound.
    fn type_satisfies_bound(&mut self, concrete_type: &Type, bound_trait: &TraitDef) -> bool {
        // check if the trait is in the library registry
        if !self.registry_contains_trait(bound_trait) {
            log_warn!(
                self.logger,
                "trait `{}` not found in library registry",
                bound_trait.trait_name
            );
        }

        // retrieve all the trait implementations for the concrete type from the type table
        let trait_implementations = self.get_trait_implementations(concrete_type);

        // check if any of the implementations match the required trait (may not be any)
        for trait_impl in trait_implementations {
            if trait_impl.implemented_trait_path.type_name == bound_trait.trait_name {
                return true;
            }
        }

        // if no matching trait implementations were found, the bound is not satisfied
        false
    }

    fn get_trait_implementations(&mut self, concrete_type: &Type) -> &[TraitImplDef] {
        // convert concrete type to its `TypePath` representation
        if let Some(type_path) = self.resolve_type_path_in_scope(concrete_type) {
            // look up the trait implementations in the type table
            if let Some(trait_impls) = self.type_table.get(&type_path) {
                return trait_impls;
            }
        } else {
            log_warn!(self.logger, "type `{concrete_type}` not found in scope");
        }

        // if no implementations are found, return an empty array
        &[]
    }

    fn current_symbol_table(&self) -> SymbolTable {
        if let Some(scope) = self.scope_stack.last() {
            scope.symbols.to_owned()
        } else {
            HashMap::new()
        }
    }

    /// Helper function to resolve `Type` to `TypePath` if it exists in a symbol table in scope.
    fn resolve_type_path_in_scope(&self, ty: &Type) -> Option<TypePath> {
        match ty {
            Type::UserDefined(type_path) => {
                for scope in self.scope_stack.iter().rev() {
                    if scope.symbols.contains_key(type_path) {
                        return Some(type_path.clone());
                    }
                }

                None
            }
            _ => None,
        }
    }

    fn registry_contains_trait(&self, expected_trait: &TraitDef) -> bool {
        for lib_contents in self.lib_registry.values() {
            for module in lib_contents.iter() {
                for symbol in module.table.values() {
                    if let Symbol::Trait { path, trait_def } = symbol {
                        if path.type_name == expected_trait.trait_name
                            && &*trait_def.clone() == expected_trait
                        {
                            return true;
                        }
                    }
                }
            }
        }

        false
    }

    fn log_error(&mut self, error_kind: SemanticErrorKind, span: &Span) {
        if self
            .errors
            .iter()
            .map(|err| err.error_kind())
            .collect::<Vec<_>>()
            .contains(&error_kind)
        {
            return;
        }

        let error = CompilerError::new(error_kind, span.start(), &span.input());

        log_error!(self.logger, "{error}");
        self.errors.push(error);
    }
}

fn unify_inferred_type(ty: &mut Type, concrete_type: Type) {
    if *ty == Type::inferred_type("_") {
        if concrete_type != Type::inferred_type("_") {
            *ty = concrete_type;
        }
    }
}

fn unify_numeric_types(lhs_type: &Type, rhs_type: &mut Type) -> Result<(), SemanticErrorKind> {
    match (lhs_type, rhs_type.clone()) {
        (Type::I32, Type::I32 | Type::U8 | Type::U16 | Type::U32 | Type::U64) => {
            // *rhs_type = lhs_type.clone();
            Ok(())
        }

        (Type::I32, ty) => Err(SemanticErrorKind::TypeMismatchNumeric {
            expected: "`i32` or unsigned integer".to_string(),
            found: ty,
        }),

        (Type::I64, Type::I32 | Type::I64 | Type::U8 | Type::U16 | Type::U32 | Type::U64) => {
            // *rhs_type = lhs_type.clone();
            Ok(())
        }

        (Type::I64, ty) => Err(SemanticErrorKind::TypeMismatchNumeric {
            expected: "integer or unsigned integer".to_string(),
            found: ty,
        }),

        (Type::U8, Type::U8) => {
            // *rhs_type = lhs_type.clone();
            Ok(())
        }

        (Type::U8, ty) => Err(SemanticErrorKind::TypeMismatchNumeric {
            expected: "`u8`".to_string(),
            found: ty,
        }),

        (Type::U16, Type::U8 | Type::U16) => {
            // *rhs_type = lhs_type.clone();
            Ok(())
        }

        (Type::U16, ty) => Err(SemanticErrorKind::TypeMismatchNumeric {
            expected: "`u16` or `u8`".to_string(),
            found: ty,
        }),

        (Type::U32, Type::U8 | Type::U16 | Type::U32) => {
            // *rhs_type = lhs_type.clone();
            Ok(())
        }

        (Type::U32, ty) => Err(SemanticErrorKind::TypeMismatchNumeric {
            expected: "`u32` or smaller unsigned integer".to_string(),
            found: ty,
        }),

        (Type::U64, Type::U8 | Type::U16 | Type::U32 | Type::U64) => {
            // *rhs_type = lhs_type.clone();
            Ok(())
        }

        (Type::U64, ty) => Err(SemanticErrorKind::TypeMismatchNumeric {
            expected: "`u64` or smaller unsigned integer".to_string(),
            found: ty,
        }),

        (Type::U256, Type::U256) => {
            // *rhs_type = lhs_type.clone();
            Ok(())
        }
        (Type::U256, ty) => Err(SemanticErrorKind::TypeMismatchNumeric {
            expected: "`u256`".to_string(),
            found: ty,
        }),

        (Type::U512, Type::U256 | Type::U512) => {
            // *rhs_type = lhs_type.clone();
            Ok(())
        }

        (Type::U512, ty) => Err(SemanticErrorKind::TypeMismatchNumeric {
            expected: "`u512` or `u256`".to_string(),
            found: ty,
        }),

        (Type::F32, Type::F32) => {
            // *rhs_type = lhs_type.clone();
            Ok(())
        }

        (Type::F32, ty) => Err(SemanticErrorKind::TypeMismatchNumeric {
            expected: "`f32`".to_string(),
            found: ty,
        }),

        (Type::F64, Type::F32 | Type::F64) => {
            // *rhs_type = lhs_type.clone();
            Ok(())
        }

        (Type::F64, ty) => Err(SemanticErrorKind::TypeMismatchNumeric {
            expected: "`f64` or `f32`".to_string(),
            found: ty,
        }),

        (_, ty) => Err(SemanticErrorKind::TypeMismatchNumeric {
            expected: "numeric values with matching types".to_string(),
            found: ty,
        }),
    }
}

/// Attempt to unify the types of two `Result` types, specifically between an inferred type
/// and a context type. This function is used to ensure that the `Ok` and `Err` variants of
/// an inferred `Result` type match the expected types defined in the context.
fn unify_result_types(ty: &mut Type, context_type: &Type) -> Result<(), SemanticErrorKind> {
    let ty_clone = ty.clone();

    match (ty, context_type) {
        (
            Type::Result {
                ok_type: inf_ok,
                err_type: inf_err,
            },
            Type::Result {
                ok_type: ctx_ok,
                err_type: ctx_err,
            },
        ) => {
            if **inf_ok == Type::inferred_type("_") {
                *inf_ok = ctx_ok.clone();
            } else if **ctx_ok != Type::inferred_type("_") && **inf_ok != **ctx_ok {
                return Err(SemanticErrorKind::TypeMismatchResultExpr {
                    variant: Keyword::Ok,
                    expected: *ctx_ok.clone(),
                    found: *(*inf_ok).clone(),
                });
            }

            if **inf_err == Type::inferred_type("_") {
                *inf_err = ctx_err.clone();
            } else if **ctx_err != Type::inferred_type("_") && **inf_err != **ctx_err {
                return Err(SemanticErrorKind::TypeMismatchResultExpr {
                    variant: Keyword::Err,
                    expected: *ctx_err.clone(),
                    found: *(*inf_err).clone(),
                });
            }
            Ok(())
        }
        _ => Err(SemanticErrorKind::UnexpectedType {
            expected: context_type.to_string(),
            found: ty_clone,
        }),
    }
}

fn unify_self_type(ty: &mut Type, object_type: Type) {
    if matches!(ty, Type::SelfType { .. }) {
        if !matches!(object_type, Type::SelfType { .. })
            && !matches!(object_type, Type::InferredType(_))
        {
            *ty = object_type;
        }
    }

    // if *ty == Type::SELF_TYPE {
    //     if object_type != Type::SELF_TYPE && object_type != Type::inferred_type("_") {
    //         *ty = object_type;
    //     }
    // }
}
