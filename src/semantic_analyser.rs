//! # Semantic Analyser
//!
//! Responsible for performing semantic analysis on the abstract syntax tree (AST) generated by
//! the parser. This analysis ensures that the code is semantically correct according to
//! the language's rules, checking for issues such as type mismatches, undefined variables
//! and incorrect patterns in the code.

mod expr;
mod patt;
mod symbol_table;

#[cfg(test)]
mod tests;

use crate::{
    ast::{
        EnumVariantType, Expression, FunctionItem, FunctionOrMethodParam, Identifier, ImportDecl,
        InferredType, InherentImplItem, Item, Keyword, SelfType, Statement, StructDef, TraitDef,
        TraitDefItem, TraitImplDef, TraitImplItem, TupleStructDef, TupleStructDefField, Type,
        TypePath, UnitType, Visibility,
    },
    error::{CompilerError, SemanticErrorKind},
    logger::{LogLevel, Logger},
    parser::{
        ty::{build_item_path, get_type_paths},
        Program,
    },
    span::{Span, Spanned},
};

use std::{collections::HashMap, rc::Rc};

use expr::{analyse_expr, wrap_into_expression};
use symbol_table::{Scope, ScopeKind, Symbol, SymbolTable};

/// Mapping from a `TypePath`` (representing a concrete type) to a vector of `TraitImplDef`
/// (representing implemented traits)
type TypeTable = HashMap<TypePath, Vec<TraitImplDef>>;

/// Struct responsible for performing semantic analysis on the abstract syntax tree (AST)
/// of the program. It manages the scopes, symbol tables, and errors encountered during
/// the analysis phase.
#[allow(dead_code)]
struct SemanticAnalyser {
    scope_stack: Vec<Scope>,
    module_registry: HashMap<TypePath, SymbolTable>,
    errors: Vec<CompilerError<SemanticErrorKind>>,
    logger: Logger,
    type_table: TypeTable,
}

#[allow(dead_code)]
impl SemanticAnalyser {
    /// Construct a new `SemanticAnalyser` instance. Initialize the logger, external symbols
    /// and module registry. Add any external code (e.g., library functions) to the global scope
    /// if provided.
    pub(crate) fn new(log_level: LogLevel, external_code: Option<SymbolTable>) -> Self {
        let mut logger = Logger::new(log_level);
        let mut external_symbols: SymbolTable = HashMap::new();
        let mut module_registry: HashMap<TypePath, SymbolTable> = HashMap::new();

        if let Some(ext) = external_code {
            logger.debug("external code detected – importing …");

            for (path, ref sym) in ext {
                if let Symbol::Module { path, symbols, .. } = sym.clone() {
                    module_registry.insert(path, symbols);
                }

                // if the symbol is a trait implementation, also update the `TypeTable` to add
                // trait implementations for a given implementing type (replace the current empty
                // `HashMap`)

                external_symbols.insert(path, sym.clone());
            }

            logger.info("imported external code");
        }

        SemanticAnalyser {
            scope_stack: vec![
                Scope {
                    scope_kind: ScopeKind::Public,
                    symbols: external_symbols,
                },
                Scope {
                    scope_kind: ScopeKind::Lib,
                    symbols: HashMap::new(),
                },
            ],
            module_registry,
            errors: Vec::new(),
            logger,
            type_table: HashMap::new(),
        }
    }

    /// Push a new scope onto the scope stack and log the action.
    fn enter_scope(&mut self, scope_kind: ScopeKind) {
        self.logger
            .debug(&format!("entering new scope: `{scope_kind:?}` …"));

        self.scope_stack.push(Scope {
            scope_kind,
            symbols: HashMap::new(),
        });
    }

    /// Pop the top scope from the scope stack and log the action.
    fn exit_scope(&mut self) -> Option<Scope> {
        if let Some(exited_scope) = self.scope_stack.pop() {
            self.logger
                .debug(&format!("exited scope: `{:?}`", exited_scope.scope_kind));

            Some(exited_scope)
        } else {
            None
        }
    }

    /// Insert a symbol into the current scope's symbol table.
    fn insert(&mut self, path: TypePath, symbol: Symbol) -> Result<(), SemanticErrorKind> {
        if let Some(curr_scope) = self.scope_stack.last_mut() {
            self.logger.debug(&format!(
                "inserting symbol `{symbol}` into scope `{:?}` at path `{path}` …",
                curr_scope.scope_kind
            ));

            curr_scope.symbols.insert(path, symbol);

            Ok(())
        } else {
            Err(SemanticErrorKind::UndefinedScope)
        }
    }

    /// Look up a symbol by its path in the current scope stack, starting from the innermost scope,
    /// and log the lookup result.
    fn lookup(&mut self, path: &TypePath) -> Option<&Symbol> {
        for scope in self.scope_stack.iter().rev() {
            if let Some(symbol) = scope.symbols.get(path) {
                self.logger.debug(&format!(
                    "found symbol `{symbol}` in scope `{:?}` at path `{path}`",
                    scope.scope_kind
                ));

                return Some(symbol);
            }
        }

        self.logger
            .warn(&format!("path `{path}` not found in any scope"));

        None
    }

    /// Initiate semantic analysis on the provided program. This involves analysing all statements
    /// within the program, checking for type mismatches and validating symbol definitions.
    fn analyse_program(
        &mut self,
        program: &Program,
        path: TypePath,
    ) -> Result<(), Vec<CompilerError<SemanticErrorKind>>> {
        self.logger.debug(&format!("starting semantic analysis …"));

        let program_path = if let Some(Scope {
            scope_kind: ScopeKind::Lib,
            ..
        }) = self.scope_stack.last()
        {
            let mut prefix = vec![Identifier::from("lib")];

            if let Some(mut segments) = path.associated_type_path_prefix_opt {
                if segments.get(0) == Some(&Identifier::from("lib")) {
                    segments.remove(0);
                }

                prefix.append(&mut segments);
            }

            if path.type_name != Identifier::from("") {
                prefix.push(path.type_name);
            }

            TypePath::from(prefix)
        } else {
            path
        };

        self.enter_scope(ScopeKind::RootModule(program_path.to_string()));

        for stmt in &program.statements {
            self.analyse_stmt(stmt, &program_path)
                .map_err(|_| self.errors.clone())?
        }

        if !self.errors.is_empty() {
            return Err(self.errors.clone());
        }

        self.logger
            .info("semantic analysis complete, no errors detected");

        Ok(())
    }

    /// Analyse individual statements within the program, determining their validity and handling
    /// specific types of statements, such as variable declarations, item definitions and expressions.
    /// Check for semantic correctness and ensures that the statement adheres to the expected types
    /// and scope rules.
    fn analyse_stmt(
        &mut self,
        statement: &Statement,
        root: &TypePath,
    ) -> Result<(), SemanticErrorKind> {
        match statement {
            Statement::Let(ls) => {
                self.logger
                    .trace(&format!("analysing let statement: `{statement}`"));

                // variables declared must have a type and are assigned the unit type if not;
                // this prevents uninitialized variable errors
                let mut value_type = if let Some(val) = &ls.value_opt {
                    analyse_expr(self, val, root)?
                } else {
                    Type::UnitType(UnitType)
                };

                // get the type annotation if there is one, otherwise assume the value's type
                let declared_type = match &ls.type_ann_opt {
                    Some(ty) => ty.clone(),
                    _ => value_type.clone(),
                };

                self.unify_types(&declared_type, &mut value_type)?;

                // check that the value matches the type annotation
                if value_type != declared_type {
                    return Err(SemanticErrorKind::TypeMismatchDeclaredType {
                        actual_type: value_type.clone(),
                        declared_type: declared_type.clone(),
                    });
                }

                let assignee_path = TypePath::from(ls.assignee.name.clone());

                let symbol = match &value_type {
                    Type::I32(_)
                    | Type::I64(_)
                    | Type::U8(_)
                    | Type::U16(_)
                    | Type::U32(_)
                    | Type::U64(_)
                    | Type::U256(_)
                    | Type::U512(_)
                    | Type::F32(_)
                    | Type::F64(_)
                    | Type::Byte(_)
                    | Type::B2(_)
                    | Type::B4(_)
                    | Type::B8(_)
                    | Type::B16(_)
                    | Type::B32(_)
                    | Type::H160(_)
                    | Type::H256(_)
                    | Type::H512(_)
                    | Type::Str(_)
                    | Type::Char(_)
                    | Type::Bool(_)
                    | Type::UnitType(_)
                    | Type::GroupedType(_)
                    | Type::Array { .. }
                    | Type::Tuple(_)
                    | Type::FunctionPtr(_)
                    | Type::Reference { .. }
                    | Type::SelfType(_)
                    | Type::InferredType(_)
                    | Type::Vec { .. }
                    | Type::Mapping { .. }
                    | Type::Option { .. }
                    | Type::Result { .. } => Symbol::Variable {
                        name: ls.assignee.name.clone(),
                        var_type: value_type,
                    },
                    Type::UserDefined(tp) => {
                        let type_path = self.check_path(&tp, root, "type".to_string())?;

                        match self.lookup(&type_path) {
                            Some(sym) => sym.clone(),
                            _ => Symbol::Variable {
                                name: ls.assignee.name.clone(),
                                var_type: value_type,
                            },
                        }
                    }
                    Type::Generic { name, bound_opt } => Symbol::Variable {
                        name: name.clone(),
                        var_type: Type::UserDefined(
                            bound_opt
                                .clone()
                                .unwrap_or(TypePath::from(Identifier::from("_"))),
                        ),
                    },
                };

                // add the variable to the symbol table
                self.insert(assignee_path, symbol)?;
            }

            Statement::Item(item) => match item {
                Item::ImportDecl(id) => {
                    self.logger
                        .trace(&format!("analysing import declaration: `{statement}`"));

                    match self.analyse_import(&id, root) {
                        Ok(_) => (),
                        Err(err) => self.log_error(err, &id.span),
                    }
                }

                Item::AliasDecl(ad) => {
                    self.logger
                        .trace(&format!("analysing alias declaration: `{statement}`"));

                    let alias_path = build_item_path(root, TypePath::from(ad.alias_name.clone()));

                    self.insert(
                        alias_path.clone(),
                        Symbol::Alias {
                            path: alias_path,
                            visibility: ad.visibility.clone(),
                            alias_name: ad.alias_name.clone(),
                            original_type_opt: ad.original_type_opt.clone(),
                        },
                    )?;
                }

                Item::ConstantDecl(cd) => {
                    self.logger
                        .trace(&format!("analysing constant declaration: `{statement}`"));

                    let value_type = match &cd.value_opt {
                        Some(val) => {
                            let value = wrap_into_expression(val.clone());
                            Some(analyse_expr(self, &value, root)?)
                        }
                        _ => None,
                    };

                    self.unify_types(
                        &cd.constant_type,
                        &mut value_type
                            .clone()
                            .unwrap_or(Type::InferredType(InferredType {
                                name: Identifier::from("_"),
                            })),
                    )?;

                    if value_type.clone().is_some_and(|t| t != *cd.constant_type) {
                        return Err(SemanticErrorKind::TypeMismatchDeclaredType {
                            declared_type: *cd.constant_type.clone(),
                            actual_type: value_type.unwrap(),
                        });
                    }

                    let constant_path =
                        build_item_path(root, TypePath::from(cd.constant_name.clone()));

                    self.insert(
                        constant_path.clone(),
                        Symbol::Constant {
                            path: constant_path,
                            visibility: cd.visibility.clone(),
                            constant_name: cd.constant_name.clone(),
                            constant_type: value_type.unwrap_or(Type::InferredType(InferredType {
                                name: Identifier::from("_"),
                            })),
                        },
                    )?;
                }

                Item::StaticVarDecl(s) => {
                    self.logger.trace(&format!(
                        "analysing static variable declaration: `{statement}`"
                    ));

                    let mut assignee_type = match &s.assignee_opt {
                        Some(a_expr) => {
                            let assignee = wrap_into_expression(*a_expr.clone());
                            analyse_expr(self, &assignee, root)?
                        }
                        _ => Type::InferredType(InferredType {
                            name: Identifier::from("_"),
                        }),
                    };

                    self.unify_types(&s.var_type, &mut assignee_type)?;

                    if assignee_type != s.var_type.clone() {
                        return Err(SemanticErrorKind::TypeMismatchDeclaredType {
                            declared_type: s.var_type.clone(),
                            actual_type: assignee_type,
                        });
                    }

                    let static_var_path = build_item_path(root, TypePath::from(s.var_name.clone()));

                    self.insert(
                        static_var_path,
                        Symbol::Variable {
                            name: s.var_name.clone(),
                            var_type: s.var_type.clone(),
                        },
                    )?;
                }

                Item::ModuleItem(m) => {
                    // TODO: sort out visibility

                    let mut module_errors: Vec<SemanticErrorKind> = Vec::new();

                    let module_path = build_item_path(root, TypePath::from(m.module_name.clone()));

                    self.logger
                        .debug(&format!("analysing module item: `{module_path}` …"));

                    let scope_kind = ScopeKind::Module(module_path.to_string());

                    let mut module_scope = Scope {
                        scope_kind: scope_kind.clone(),
                        symbols: HashMap::new(),
                    };

                    self.enter_scope(scope_kind);

                    if let Some(items) = &m.items_opt {
                        for item in items.iter() {
                            match self.analyse_stmt(&Statement::Item(item.clone()), &module_path) {
                                Ok(_) => (),
                                Err(err) => {
                                    self.log_error(err.clone(), &item.span());
                                    module_errors.push(err)
                                }
                            }
                        }
                    }

                    if !module_errors.is_empty() {
                        return Err(SemanticErrorKind::ModuleErrors {
                            name: m.module_name.clone(),
                        });
                    }

                    if let Some(curr_scope) = self.scope_stack.pop() {
                        self.logger
                            .debug(&format!("exiting scope: `{:?}`", curr_scope.scope_kind));

                        module_scope = curr_scope;
                    }

                    self.insert(
                        module_path.clone(),
                        Symbol::Module {
                            path: module_path.clone(),
                            module: m.clone(),
                            symbols: module_scope.symbols.clone(),
                        },
                    )?;

                    self.logger.debug(&format!(
                        "inserting symbols into module at path: `{module_path}` …"
                    ));

                    self.module_registry
                        .insert(module_path, module_scope.symbols);
                }

                Item::TraitDef(t) => {
                    let trait_name_path = TypePath::from(t.trait_name.clone());
                    let trait_def_path = build_item_path(root, trait_name_path.clone());

                    self.logger
                        .debug(&format!("analysing trait definition: `{trait_def_path}` …",));

                    self.insert(
                        trait_def_path.clone(),
                        Symbol::Trait {
                            path: trait_name_path,
                            trait_def: t.clone(),
                        },
                    )?;

                    // TODO: insert optional generics into scope if they are not already

                    if let Some(items) = &t.trait_items_opt {
                        // self.enter_scope(ScopeKind::TraitDef(trait_def_path.to_string()));

                        for i in items.iter() {
                            match i {
                                TraitDefItem::AliasDecl(ad) => {
                                    self.analyse_stmt(
                                        &Statement::Item(Item::AliasDecl(ad.clone())),
                                        &trait_def_path,
                                    )?;
                                }
                                TraitDefItem::ConstantDecl(cd) => self.analyse_stmt(
                                    &Statement::Item(Item::ConstantDecl(cd.clone())),
                                    &trait_def_path,
                                )?,
                                TraitDefItem::FunctionItem(fi) => {
                                    let function_name_path =
                                        TypePath::from(fi.function_name.clone());

                                    let function_def_path = build_item_path(
                                        &trait_def_path,
                                        function_name_path.clone(),
                                    );

                                    self.insert(
                                        function_def_path,
                                        Symbol::Function {
                                            path: function_name_path,
                                            function: fi.clone(),
                                        },
                                    )?;

                                    match self.analyse_function_def(
                                        fi,
                                        &trait_def_path,
                                        true,
                                        false,
                                    ) {
                                        Ok(_) => (),
                                        Err(err) => self.log_error(err, &t.span),
                                    }
                                }
                            }
                        }
                    }
                }

                Item::EnumDef(e) => {
                    let enum_name_path = TypePath::from(e.enum_name.clone());
                    let enum_def_path = build_item_path(root, enum_name_path.clone());

                    self.logger
                        .debug(&format!("analysing enum definition: `{enum_def_path}` …"));

                    self.insert(
                        enum_def_path.clone(),
                        Symbol::Enum {
                            path: enum_name_path,
                            enum_def: e.clone(),
                        },
                    )?;

                    // TODO: insert optional generics into scope if they are not already

                    for variant in e.variants.clone() {
                        let variant_path = build_item_path(
                            &enum_def_path,
                            TypePath::from(variant.variant_name.clone()),
                        );

                        if let Some(variant_type) = variant.variant_type_opt {
                            match variant_type {
                                EnumVariantType::Struct(s) => {
                                    self.insert(
                                        variant_path.clone(),
                                        Symbol::Struct {
                                            path: variant_path,
                                            struct_def: StructDef {
                                                attributes_opt: None,
                                                visibility: Visibility::Private,
                                                kw_struct: Keyword::Anonymous,
                                                struct_name: variant.variant_name,
                                                generic_params_opt: None,
                                                fields_opt: Some(s.struct_fields),
                                                span: Span::default(),
                                            },
                                        },
                                    )?;
                                }
                                EnumVariantType::TupleStruct(t) => {
                                    self.insert(
                                        variant_path.clone(),
                                        Symbol::TupleStruct {
                                            path: variant_path.clone(),
                                            tuple_struct_def: TupleStructDef {
                                                attributes_opt: None,
                                                visibility: Visibility::Private,
                                                kw_struct: Keyword::Anonymous,
                                                struct_name: Identifier::from(
                                                    &variant_path.to_string(),
                                                ),
                                                generic_params_opt: None,
                                                fields_opt: {
                                                    let mut elements: Vec<TupleStructDefField> =
                                                        Vec::new();

                                                    for elem_type in t.element_types {
                                                        let elem = TupleStructDefField {
                                                            attributes_opt: None,
                                                            visibility: Visibility::Private,
                                                            field_type: Box::new(elem_type),
                                                        };

                                                        elements.push(elem);
                                                    }

                                                    Some(elements)
                                                },
                                                span: Span::default(),
                                            },
                                        },
                                    )?;
                                }
                            }
                        } else {
                            self.insert(
                                variant_path.clone(),
                                Symbol::Variable {
                                    name: Identifier::from(&variant_path.to_string()),
                                    var_type: Type::UserDefined(variant_path),
                                },
                            )?;
                        }
                    }
                }

                Item::StructDef(s) => {
                    let struct_name_path = TypePath::from(s.struct_name.clone());
                    let struct_def_path = build_item_path(root, struct_name_path.clone());

                    self.logger.debug(&format!(
                        "analysing struct definition: `{struct_def_path}` …"
                    ));

                    self.insert(
                        struct_def_path,
                        Symbol::Struct {
                            path: struct_name_path,
                            struct_def: s.clone(),
                        },
                    )?;

                    // TODO: insert optional generics into scope if they are not already
                }

                Item::TupleStructDef(ts) => {
                    let struct_name_path = TypePath::from(ts.struct_name.clone());
                    let tuple_struct_path = build_item_path(root, struct_name_path.clone());

                    self.logger.debug(&format!(
                        "analysing tuple struct definition: `{tuple_struct_path}` …"
                    ));

                    self.insert(
                        tuple_struct_path,
                        Symbol::TupleStruct {
                            path: struct_name_path,
                            tuple_struct_def: ts.clone(),
                        },
                    )?;

                    // TODO: insert optional generics into scope if they are not already
                }

                Item::InherentImplDef(iid) => {
                    let type_path = build_item_path(root, iid.nominal_type.clone());

                    self.logger.debug(&format!(
                        "analysing inherent implementation for type: `{type_path}` …"
                    ));

                    if let Some(items) = &iid.associated_items_opt {
                        // self.enter_scope(ScopeKind::Impl(type_path.to_string()));

                        for i in items.iter() {
                            match i {
                                InherentImplItem::ConstantDecl(cd) => self.analyse_stmt(
                                    &Statement::Item(Item::ConstantDecl(cd.clone())),
                                    &type_path,
                                )?,
                                InherentImplItem::FunctionItem(fi) => {
                                    let function_name_path =
                                        TypePath::from(fi.function_name.clone());

                                    let function_def_path =
                                        build_item_path(&type_path, function_name_path.clone());

                                    self.insert(
                                        function_def_path.clone(),
                                        Symbol::Function {
                                            path: function_name_path,
                                            function: fi.clone(),
                                        },
                                    )?;

                                    match self.analyse_function_def(fi, &type_path, true, false) {
                                        Ok(_) => (),
                                        Err(err) => self.log_error(err, &iid.span),
                                    }
                                }
                            }
                        }

                        // self.exit_scope();
                    }
                }

                Item::TraitImplDef(t) => {
                    let trait_impl_path = match &t.implementing_type {
                        Type::UserDefined(tp) => build_item_path(
                            &build_item_path(root, tp.clone()),
                            TypePath::from(t.implemented_trait_path.type_name.clone()),
                        ),
                        ty => {
                            return Err(SemanticErrorKind::UnexpectedType {
                                expected: "user-defined type".to_string(),
                                found: ty.clone(),
                            })
                        }
                    };

                    self.logger.debug(&format!(
                        "analysing trait `{}` implementation for type `{}` …",
                        t.implemented_trait_path, t.implementing_type
                    ));

                    self.add_trait_implementation(trait_impl_path.clone(), t.clone());

                    if let Some(items) = &t.associated_items_opt {
                        // self.enter_scope(ScopeKind::TraitImpl(trait_impl_path.to_string()));

                        for i in items.iter() {
                            match i {
                                TraitImplItem::AliasDecl(ad) => self.analyse_stmt(
                                    &Statement::Item(Item::AliasDecl(ad.clone())),
                                    &trait_impl_path,
                                )?,
                                TraitImplItem::ConstantDecl(cd) => self.analyse_stmt(
                                    &Statement::Item(Item::ConstantDecl(cd.clone())),
                                    &trait_impl_path,
                                )?,
                                TraitImplItem::FunctionItem(fi) => {
                                    let function_impl_path = build_item_path(
                                        &trait_impl_path,
                                        TypePath::from(fi.function_name.clone()),
                                    );

                                    self.insert(
                                        function_impl_path.clone(),
                                        Symbol::Function {
                                            path: function_impl_path,
                                            function: fi.clone(),
                                        },
                                    )?;

                                    match self.analyse_function_def(
                                        fi,
                                        &trait_impl_path,
                                        true,
                                        true,
                                    ) {
                                        Ok(_) => (),
                                        Err(err) => self.log_error(err, &t.span),
                                    }
                                }
                            }
                        }
                    }
                }

                Item::FunctionItem(f) => {
                    let function_name_path = TypePath::from(f.function_name.clone());
                    let function_item_path = build_item_path(root, function_name_path.clone());

                    self.logger.debug(&format!(
                        "analysing function item: `{function_item_path}({:?}) -> {}`",
                        f.params_opt.clone().unwrap_or(Vec::new()),
                        f.return_type_opt
                            .clone()
                            .unwrap_or(Box::new(Type::UnitType(UnitType)))
                    ));

                    self.insert(
                        function_item_path,
                        Symbol::Function {
                            path: function_name_path,
                            function: f.clone(),
                        },
                    )?;

                    // TODO: insert optional generics into scope if they are not already

                    match self.analyse_function_def(f, root, false, false) {
                        Ok(_) => (),
                        Err(err) => {
                            self.log_error(err, &f.span);
                        }
                    }
                }
            },

            Statement::Expression(expr) => {
                self.logger
                    .trace(&format!("analysing expression statement: `{statement}`"));

                match analyse_expr(self, expr, root) {
                    Ok(_) => (),
                    Err(e) => self.log_error(e, &expr.span()),
                }
            }
        }

        Ok(())
    }

    /// Analyse a function definition within a specific context, including its parameters,
    /// body, and return type.
    fn analyse_function_def(
        &mut self,
        f: &FunctionItem,
        path: &TypePath,
        is_associated_func: bool,
        is_trait_impl: bool,
    ) -> Result<(), SemanticErrorKind> {
        // What is the root path? [i.e., path to the function, excluding the function name]
        // Options:
        // * module (e.g., `lib::some_module` or just `lib`)
        // * object implementation (e.g., `lib::some_module::SomeObject`)
        // * trait implementation (e.g., `lib::some_module::SomeObject::SomeTrait`)

        self.logger
            .trace("entering `SemanticAnalyser::analyse_function_def()` …");

        let function_root = if is_trait_impl {
            if let Some(prefix) = &path.associated_type_path_prefix_opt {
                TypePath::from(prefix.clone())
            } else {
                path.clone()
            }
        } else {
            path.clone()
        };

        // append the function name to the root
        let full_path = build_item_path(&function_root, TypePath::from(f.function_name.clone()));

        println!("function path: `{full_path}`");

        self.enter_scope(ScopeKind::Function(full_path.to_string()));

        // register generic parameters in the local scope
        if let Some(generic_params) = &f.generic_params_opt {
            for generic_param in &generic_params.params {
                self.insert(
                    TypePath::from(generic_param.name.clone()),
                    Symbol::Variable {
                        name: generic_param.name.clone(),
                        var_type: Type::Generic {
                            name: generic_param.name.clone(),
                            bound_opt: generic_param.type_bound_opt.clone(),
                        },
                    },
                )?;
            }
        }

        if let Some(params) = &f.params_opt {
            let param_types: Vec<Type> = params.iter().map(|p| p.param_type()).collect();

            for (param, mut param_type) in params.iter().zip(param_types) {
                if param_type == Type::SelfType(SelfType) {
                    if is_associated_func {
                        param_type = Type::UserDefined(function_root.clone());
                    }
                }

                let param_path = TypePath::from(param.param_name());

                println!("param path: `{param_path}`, param_type: `{param_type:?}`");

                match param_type {
                    Type::Generic { name, .. } => {
                        match self.lookup(&TypePath::from(name.clone())) {
                            Some(_) => (),
                            None => {
                                return Err(SemanticErrorKind::UndeclaredGenericParams {
                                    found: format!("`{name}`"),
                                })
                            }
                        }
                    }

                    Type::FunctionPtr(fp) => {
                        self.insert(
                            param_path.clone(),
                            Symbol::Function {
                                path: param_path.clone(),
                                function: FunctionItem {
                                    attributes_opt: None,
                                    visibility: Visibility::Private,
                                    kw_func: Keyword::Anonymous,
                                    function_name: Identifier::from(""),
                                    generic_params_opt: None,
                                    params_opt: fp.params_opt,
                                    return_type_opt: fp.return_type_opt,
                                    block_opt: None,
                                    span: Span::default(),
                                },
                            },
                        )?;
                    }

                    Type::UserDefined(tp) => {
                        let type_path =
                            self.check_path(&tp, &path, "user-defined type".to_string())?;

                        match self.lookup(&type_path).cloned() {
                            Some(sym) => self.insert(param_path, sym.clone())?,
                            None => {
                                return Err(SemanticErrorKind::UndefinedType {
                                    name: tp.type_name,
                                });
                            }
                        }
                    }

                    ty => self.insert(
                        param_path,
                        Symbol::Variable {
                            name: param.param_name(),
                            var_type: ty,
                        },
                    )?,
                }
            }
        }

        let mut function_type = if let Some(block) = &f.block_opt {
            // split path into a vector to remove the last element (if needed), then convert back
            let mut path_vec = Vec::<Identifier>::from(path.clone());

            if is_associated_func {
                path_vec.pop(); // remove associated type name
            }

            self.logger
                .trace(&format!("analysing body of function `{full_path}()` …"));

            analyse_expr(
                self,
                &Expression::Block(block.clone()),
                &TypePath::from(path_vec),
            )?
        } else {
            if let Some(ty) = &f.return_type_opt {
                *ty.clone()
            } else {
                Type::UnitType(UnitType)
            }
        };

        // check that the function type matches the return type
        if let Some(return_type) = &f.return_type_opt {
            self.unify_types(&return_type, &mut function_type)?;

            if function_type != *return_type.clone() {
                match function_type.clone() {
                    Type::Result { .. } => unify_result_types(&mut function_type, return_type)?,
                    Type::Generic { name, .. } => {
                        match self.lookup(&TypePath::from(name.clone())) {
                            Some(_) => (),
                            None => {
                                return Err(SemanticErrorKind::UndeclaredGenericParams {
                                    found: format!("`{name}`"),
                                })
                            }
                        }
                    }
                    _ => {
                        return Err(SemanticErrorKind::TypeMismatchReturnType {
                            expected: *return_type.clone(),
                            found: function_type,
                        });
                    }
                }
            }
        }

        self.logger.debug(&format!(
            "analysed function: `{full_path}() -> {}`",
            f.return_type_opt
                .clone()
                .unwrap_or(Box::new(Type::UnitType(UnitType)))
        ));

        self.exit_scope();

        Ok(())
    }

    /// Analyse an import declaration, resolving and inserting symbols from the imported
    /// modules into the current scope.
    fn analyse_import(
        &mut self,
        import_decl: &ImportDecl,
        module_root: &TypePath,
    ) -> Result<(), SemanticErrorKind> {
        let path_segments = import_decl.import_tree.path_segments.clone();

        let import_paths = get_type_paths(path_segments);

        println!("import_paths: {:#?}", import_paths);

        for path in import_paths {
            let import_root = if let Some(ref ids) = path.associated_type_path_prefix_opt {
                if !ids.is_empty() {
                    &TypePath::from(ids.to_vec())
                } else {
                    &TypePath::from(path.type_name.clone())
                }
            } else {
                module_root
            };

            println!("import root: {import_root}");

            if let Some(module) = self.module_registry.get(import_root).cloned() {
                for (item_path, symbol) in module.clone() {
                    if item_path != *module_root && item_path.type_name != Identifier::from("lib") {
                        self.insert(item_path, symbol)?;
                    }
                }

                if let Some(sym) = module.get(&path) {
                    if !module.contains_key(&path) {
                        self.insert(TypePath::from(path.type_name), sym.clone())?;
                    }

                    // in case the symbol was added without the full path (i.e., just `Symbol`)
                } else if let Some(sym) = module.get(&TypePath::from(path.type_name.clone())) {
                    if !module.contains_key(&TypePath::from(path.type_name.clone())) {
                        self.insert(TypePath::from(path.type_name), sym.clone())?;
                    }
                } else {
                    return Err(SemanticErrorKind::UndefinedSymbol {
                        name: format!("`{path}`"),
                    });
                }
            } else if let Some(sym) = self.lookup(&path).cloned() {
                if !self.module_registry.contains_key(&path) {
                    self.insert(path, sym)?;
                }
            } else {
                return Err(SemanticErrorKind::UndefinedModule {
                    name: path.type_name,
                });
            }
        }

        Ok(())
    }

    /// Attempt to resolve a given `TypePath` within the current context, searching through various
    /// namespaces and fallback mechanisms.
    fn check_path(
        &mut self,
        path: &TypePath,
        root: &TypePath,
        expected_value: String,
    ) -> Result<TypePath, SemanticErrorKind> {
        self.logger
            .trace(&format!("trying to find path at `{path}` …",));

        if self.lookup(path).is_some() {
            return Ok(path.clone());
        }

        if path.type_name == Identifier::from("lib") {
            return Err(SemanticErrorKind::UnexpectedPath {
                expected: "path to item or variable".to_string(),
                found: Identifier::from("lib"),
            });
        }

        // check the module registry
        for (ref module_name, module_items) in self.module_registry.clone().into_iter() {
            // iterate over a module
            for (item_name, symbol) in module_items.iter() {
                // if the path is an item inside a module root
                if path.type_name == item_name.type_name {
                    let item_path = build_item_path(&module_name.clone(), path.clone());

                    self.logger
                        .trace(&format!("trying to find path at `{item_path}` …",));

                    if self.lookup(&item_path).is_some() {
                        return Ok(item_path);
                    }

                    let path_prefix = if let Some(ids) = &path.associated_type_path_prefix_opt {
                        let prefix = TypePath::from(ids.clone());
                        build_item_path(&module_name, prefix)
                    } else {
                        module_name.clone()
                    };

                    let item_prefix = if let Some(ids) = &item_name.associated_type_path_prefix_opt
                    {
                        TypePath::from(ids.last().cloned().unwrap())
                    } else {
                        item_name.clone()
                    };

                    let trait_impl_path = build_item_path(&path_prefix, item_prefix);

                    let associated_item_path =
                        build_item_path(&trait_impl_path, TypePath::from(path.type_name.clone()));

                    self.logger.trace(&format!(
                        "trying to find path at `{associated_item_path}` …",
                    ));

                    if self.lookup(&associated_item_path).is_some() {
                        return Ok(associated_item_path);
                    }
                }

                // if the path is a symbol inside an item
                if path.type_name == symbol.type_path().type_name {
                    let symbol_path = build_item_path(item_name, path.clone());

                    self.logger
                        .trace(&format!("trying to find path at `{symbol_path}` …",));

                    if self.lookup(&symbol_path).is_some() {
                        return Ok(symbol_path);
                    }
                }
            }
        }

        // just concatenate `root` and `path`
        let full_path = build_item_path(root, path.clone());

        self.logger
            .trace(&format!("trying to find path at `{full_path}` …",));

        if self.lookup(&full_path).is_some() {
            return Ok(full_path);
        }

        // concatenate only `path` type name to `root` (e.g, `path` is an associated item)
        let full_path = build_item_path(root, TypePath::from(path.type_name.clone()));

        self.logger
            .trace(&format!("trying to find path at `{full_path}` …",));

        if self.lookup(&full_path).is_some() {
            return Ok(full_path);
        }

        let root_prefix = if let Some(ids) = &root.associated_type_path_prefix_opt {
            TypePath::from(ids.clone())
        } else {
            root.clone()
        };

        // concatenate only `path` to `root` without type name (e.g, `path` is an associated item)
        let full_path = build_item_path(&root_prefix, path.clone());

        self.logger
            .trace(&format!("trying to find path at `{full_path}` …",));

        if self.lookup(&full_path).is_some() {
            return Ok(full_path);
        }

        Err(SemanticErrorKind::MissingValue {
            expected: expected_value,
        })
    }

    /// Analyse a function or method call expression by resolving the provided path, validating
    /// arguments and determining the return type.
    fn analyse_call_or_method_call_expr(
        &mut self,
        path: TypePath,
        args_opt: Option<Vec<Expression>>,
    ) -> Result<Type, SemanticErrorKind> {
        self.logger
            .trace("entering `SemanticAnalyser::analyse_call_or_method_call_expr()` …");

        match self.lookup(&path).cloned() {
            Some(Symbol::Function { function, .. }) => {
                let func_params = function.params_opt.clone();
                let func_def_return_type = function.return_type_opt.clone();

                match (&args_opt, &func_params) {
                    (None, None) => match func_def_return_type {
                        Some(ty) => Ok(*ty),
                        _ => Ok(Type::UnitType(UnitType)),
                    },
                    (None, Some(params)) => {
                        let mut self_counter: usize = 0;
                        let mut func_param_counter: usize = 0;

                        for param in params {
                            if let Type::SelfType(_) = param.param_type() {
                                self_counter += 1;
                            } else {
                                func_param_counter += 1;
                            }
                        }

                        if self_counter > 1 {
                            return Err(SemanticErrorKind::MethodParamCountError);
                        }

                        if self_counter != params.len() {
                            return Err(SemanticErrorKind::FuncArgCountMismatch {
                                function_path: Identifier::from(path),
                                expected: self_counter,
                                found: self_counter + func_param_counter,
                            });
                        }

                        match func_def_return_type {
                            Some(ty) => Ok(*ty),
                            _ => Ok(Type::UnitType(UnitType)),
                        }
                    }
                    (Some(args), None) => Err(SemanticErrorKind::FuncArgCountMismatch {
                        function_path: Identifier::from(path),
                        expected: 0,
                        found: args.len(),
                    }),
                    (Some(args), Some(params)) => {
                        let mut self_counter: usize = 0;

                        for param in params {
                            if let Type::SelfType(_) = param.param_type() {
                                self_counter += 1;
                            }
                        }

                        if self_counter > 1 {
                            return Err(SemanticErrorKind::MethodParamCountError);
                        }

                        let num_func_params = params.len() - self_counter;

                        if args.len() != num_func_params {
                            return Err(SemanticErrorKind::FuncArgCountMismatch {
                                function_path: Identifier::from(path),
                                expected: params.len(),
                                found: args.len(),
                            });
                        }

                        // let mut inferred_types: HashMap<Identifier, Type> = HashMap::new();

                        for (arg, param) in args.iter().zip(params) {
                            let mut arg_type =
                                analyse_expr(self, &arg, &TypePath::from(Identifier::from("")))?;

                            let param_type = param.param_type();

                            self.unify_types(&param_type, &mut arg_type)?;

                            // if arg_type != param_type {
                            //     return Err(SemanticErrorKind::TypeMismatchArgument {
                            //         arg_id: function.function_name.clone(),
                            //         expected: param_type,
                            //         found: arg_type,
                            //     });
                            // }
                        }

                        // // ensure all constraints are satisfied for inferred types
                        // for (_, inferred_type) in inferred_types.iter() {
                        //     if let Some(ref generic_params) = function.generic_params_opt {
                        //         for param in generic_params.params.iter() {
                        //             if let Some(bound) = &param.type_bound_opt {
                        //                 if !self.satisfies_bound(inferred_type, &bound) {
                        //                     return Err(SemanticErrorKind::TypeBoundNotSatisfied {
                        //                         generic_name: param.name.clone(),
                        //                         bound: Identifier::from(bound.clone()),
                        //                         found: inferred_type.clone(),
                        //                     });
                        //                 }
                        //             }
                        //         }
                        //     }
                        // }

                        // // infer return type based on substitutions
                        // // if `func_def_return_type` is generic, substitute it with the inferred type,
                        // // else return `func_def_return_type`
                        // let inferred_return_type = substitute_generics(
                        //     &*func_def_return_type.unwrap_or(Box::new(Type::UnitType(UnitType))),
                        //     &inferred_types,
                        // )?;

                        // // TODO: what if the function call is part of an assignment expression?
                        // // TODO: (e.g., let statement), or as a param in another call expression?
                        // // TODO: or any other larger expression?
                        // // TODO: can we assume the `func_def_return_type` is the call expression type?

                        // Ok(inferred_return_type)

                        match func_def_return_type {
                            Some(ty) => Ok(*ty),
                            None => Ok(Type::UnitType(UnitType)),
                        }
                    }
                }
            }

            None => Err(SemanticErrorKind::UndefinedFunction {
                name: path.type_name,
            }),
            Some(sym) => Err(SemanticErrorKind::UnexpectedSymbol {
                name: path.type_name,
                expected: "function".to_string(),
                found: format!("`{sym}`"),
            }),
        }
    }

    /// Unifies two types, ensuring they are compatible. Returns `Ok` if they can be unified, or
    /// an `Err` if there is a type mismatch.
    fn unify_types(&mut self, type_a: &Type, type_b: &mut Type) -> Result<(), SemanticErrorKind> {
        let type_a_clone = type_a.clone();
        let type_b_clone = type_b.clone();

        match (type_a_clone, type_b_clone) {
            // if both types are the same, they are already unified
            _ if type_a == type_b => Ok(()),

            (
                Type::Generic {
                    name: name_a,
                    bound_opt: bound_a,
                },
                Type::Generic {
                    name: name_b,
                    bound_opt: bound_b,
                },
            ) => {
                if name_a == name_b {
                    // same generic, check bounds
                    if let (Some(bound_a), Some(bound_b)) = (bound_a, bound_b) {
                        if bound_a != bound_b {
                            return Err(SemanticErrorKind::TypeMismatchTypeBound {
                                expected: Identifier::from(bound_a),
                                found: Identifier::from(bound_b),
                            });
                        }
                    }
                    Ok(())
                } else {
                    Err(SemanticErrorKind::TypeMismatchUnification {
                        expected: Identifier::from(&type_a.to_string()),
                        found: Identifier::from(&type_b.to_string()),
                    })
                }
            }

            (Type::Generic { name, bound_opt }, concrete) => self.unify_generic_with_concrete(
                &mut Type::Generic {
                    name,
                    bound_opt,
                },
                &concrete,
            ),

            // if one is a concrete or generic type and the other is inferred, resolve the inference
            (concrete_or_generic, Type::InferredType(_)) => {
                self.resolve_inferred_type(type_b, concrete_or_generic)
            }

            (Type::GroupedType(grouped), matched) => {
                if *grouped != matched {
                    return Err(SemanticErrorKind::TypeMismatchUnification {
                        expected: Identifier::from(&type_a.to_string()),
                        found: Identifier::from(&type_b.to_string()),
                    });
                }

                Ok(())
            }

            (
                Type::Array {
                    element_type: elem_type_a,
                    num_elements: num_elems_a,
                },
                Type::Array {
                    element_type: elem_type_b,
                    num_elements: num_elems_b,
                },
            ) => {
                if elem_type_a != elem_type_b {
                    // array element type mismatch
                    todo!()
                }

                if num_elems_a != num_elems_b {
                    // array length mismatch
                    todo!()
                }

                Ok(())
            }

            (Type::Tuple(elem_types_a), Type::Tuple(elem_types_b)) => {
                if elem_types_a.len() != elem_types_b.len() {
                    // tuple length mismatch
                    todo!()
                }

                for (a, b) in elem_types_a.into_iter().zip(elem_types_b) {
                    if a != b {
                        // tuple element type mismatch
                        todo!()
                    }
                }

                Ok(())
            }

            (Type::FunctionPtr(ptr_a), Type::FunctionPtr(ptr_b)) => {
                match (ptr_a.params_opt, ptr_b.params_opt) {
                    (None, None) => (),
                    (None, Some(_)) => todo!(), // too many params
                    (Some(_), None) => todo!(), // missing params
                    (Some(params_a), Some(params_b)) => {
                        if params_a.len() != params_b.len() {
                            // mismatch in num params
                            todo!()
                        }

                        for (param_a, param_b) in params_a.iter().zip(params_b) {
                            match (param_a, param_b) {
                                (
                                    FunctionOrMethodParam::FunctionParam(func_param_a),
                                    FunctionOrMethodParam::FunctionParam(func_param_b),
                                ) => {
                                    if *func_param_a != func_param_b {
                                        // func param type mismatch
                                        todo!()
                                    }
                                }
                                (
                                    FunctionOrMethodParam::FunctionParam(_),
                                    FunctionOrMethodParam::MethodParam(_),
                                ) => todo!(), // unexpected `self` param
                                (
                                    FunctionOrMethodParam::MethodParam(_),
                                    FunctionOrMethodParam::FunctionParam(_),
                                ) => todo!(), // missing `self` param
                                (
                                    FunctionOrMethodParam::MethodParam(self_param_a),
                                    FunctionOrMethodParam::MethodParam(self_param_b),
                                ) => {
                                    match (
                                        self_param_a.reference_op_opt,
                                        self_param_b.reference_op_opt,
                                    ) {
                                        (None, None) => (),
                                        (None, Some(_)) => todo!(), // unexpected reference operator
                                        (Some(_), None) => todo!(), // missing reference operator
                                        (Some(ref_op_a), Some(ref_op_b)) => {
                                            if ref_op_a != ref_op_b {
                                                // reference operator mismatch
                                                todo!()
                                            }
                                        }
                                    }

                                    match (self_param_a.kw_self, self_param_b.kw_self) {
                                        (Keyword::SelfKeyword, Keyword::SelfKeyword) => (),
                                        (Keyword::SelfKeyword, _) => todo!(), // unexpected keyword
                                        (_, _) => todo!(),                    //  invalid keyword
                                    }
                                }
                            }
                        }
                    }
                }

                match (ptr_a.return_type_opt, ptr_b.return_type_opt) {
                    (None, None) => (),
                    (None, Some(_)) => todo!(), // unexpected return type
                    (Some(_), None) => todo!(), // missing return type
                    (Some(return_type_a), Some(return_type_b)) => {
                        if return_type_a != return_type_b {
                            // return type mismatch
                            todo!()
                        }
                    }
                }

                Ok(())
            }

            (
                Type::Reference {
                    reference_op: ref_op_a,
                    inner_type: inner_type_a,
                },
                Type::Reference {
                    reference_op: ref_op_b,
                    inner_type: inner_type_b,
                },
            ) => {
                if ref_op_a != ref_op_b {
                    // reference operator mismatch
                    todo!()
                }

                if inner_type_a != inner_type_b {
                    // inner type mismatch
                    todo!()
                }

                Ok(())
            }

            (
                Type::Vec {
                    element_type: elem_type_a,
                },
                Type::Vec {
                    element_type: elem_type_b,
                },
            ) => {
                if elem_type_a != elem_type_b {
                    // vector element type mismatch
                    todo!()
                }

                Ok(())
            }

            (
                Type::Mapping {
                    key_type: key_type_a,
                    value_type: val_type_a,
                },
                Type::Mapping {
                    key_type: key_type_b,
                    value_type: val_type_b,
                },
            ) => {
                if key_type_a != key_type_b {
                    // mapping key type mismatch
                    todo!()
                }

                if val_type_a != val_type_b {
                    // mapping value type mismatch
                    todo!()
                }

                Ok(())
            }

            (
                Type::Option {
                    inner_type: inner_type_a,
                },
                Type::Option {
                    inner_type: inner_type_b,
                },
            ) => {
                if inner_type_a != inner_type_b {
                    // inner type mismatch
                    todo!()
                }

                Ok(())
            }

            (
                Type::Result {
                    ok_type: ok_type_a,
                    err_type: err_type_a,
                },
                Type::Result {
                    ok_type: ok_type_b,
                    err_type: err_type_b,
                },
            ) => {
                if ok_type_a != ok_type_b {
                    // result type  mismatch (`Ok` variant)
                }

                if err_type_a != err_type_b {
                    // result type mismatch (`Err` variant)
                }

                Ok(())
            }

            (Type::UserDefined(type_path_a), Type::UserDefined(type_path_b)) => {
                if type_path_a != type_path_b {
                    // user defined type mismatch
                    todo!()
                }

                Ok(())
            }

            // TODO: handle other cases for concrete types (numeric, str, char, bool)
            _ => {
                // check if one is a generic and substitute, or handle type mismatch
                Err(SemanticErrorKind::TypeMismatchUnification {
                    expected: Identifier::from(&type_a.to_string()),
                    found: Identifier::from(&type_b.to_string()),
                })
            }
        }
    }

    fn resolve_inferred_type(
        &mut self,
        inferred: &mut Type,
        concrete: Type,
    ) -> Result<(), SemanticErrorKind> {
        if *inferred
            == Type::InferredType(InferredType {
                name: Identifier::from("_"),
            })
        {
            *inferred = concrete;
            Ok(())
        } else if *inferred == concrete {
            Ok(())
        } else {
            Err(SemanticErrorKind::UnexpectedType {
                expected: inferred.to_string(),
                found: concrete,
            })
        }
    }

    fn unify_generic_with_concrete(
        &mut self,
        generic_type: &mut Type,
        concrete_type: &Type,
    ) -> Result<(), SemanticErrorKind> {
        match generic_type {
            Type::Generic { name, bound_opt } => {
                // check if the concrete type satisfies the bounds of the generic type
                if let Some(bound_path) = bound_opt {
                    let bound_trait = self.lookup_trait(&bound_path)?;

                    // check if the concrete type implements the required trait
                    if !self.type_satisfies_bound(concrete_type, &bound_trait) {
                        return Err(SemanticErrorKind::TypeBoundNotSatisfied {
                            generic_name: name.clone(),
                            expected_bound: Identifier::from(bound_path.clone()),
                            found_type: concrete_type.clone(),
                        });
                    }
                }

                // if bounds are satisfied, perform the substitution
                self.substitute_generic_with_concrete(name, concrete_type);
                Ok(())
            }

            _ => self.unify_types(concrete_type, generic_type),
        }
    }

    /// Add a trait implementation to the type table.
    fn add_trait_implementation(&mut self, concrete_type: TypePath, trait_impl: TraitImplDef) {
        self.type_table
            .entry(concrete_type)
            .or_insert_with(Vec::new)
            .push(trait_impl);
    }

    /// Lookup logic to find the trait definition in the current scope
    fn lookup_trait(&mut self, bound_path: &TypePath) -> Result<TraitDef, SemanticErrorKind> {
        if let Some(Symbol::Trait { trait_def, .. }) = self.lookup(bound_path) {
            Ok(trait_def.clone())
        } else {
            Err(SemanticErrorKind::UndefinedSymbol {
                name: bound_path.type_name.to_string(),
            })
        }
    }

    /// Replace all occurrences of `generic_name` with `concrete_type`.
    fn substitute_generic_with_concrete(
        &mut self,
        generic_name: &Identifier,
        concrete_type: &Type,
    ) {
        let mut stack = Rc::new(&self.scope_stack);
        let stack_mut = Rc::make_mut(&mut stack);

        // iterate through the scope stack and substitute generics in all types.
        for scope in stack_mut.clone().iter_mut() {
            for symbol in scope.symbols.values_mut() {
                self.substitute_in_symbol(symbol, generic_name, concrete_type);
            }
        }
    }

    fn substitute_in_symbol(
        &mut self,
        symbol: &mut Symbol,
        generic_name: &Identifier,
        concrete_type: &Type,
    ) {
        match symbol {
            Symbol::Variable { var_type, .. } => {
                self.substitute_in_type(var_type, generic_name, concrete_type);
            }
            Symbol::Struct { struct_def, .. } => {
                self.substitute_in_struct_def(struct_def, generic_name, concrete_type);
            }
            // TODO: tuple struct
            // TODO: enum
            // TODO: trait
            Symbol::Function { function, .. } => {
                self.substitute_in_function(function, generic_name, concrete_type);
            }
            _ => {}
        }
    }

    fn substitute_in_type(
        &mut self,
        ty: &mut Type,
        generic_name: &Identifier,
        concrete_type: &Type,
    ) {
        match ty {
            Type::Generic { name, .. } if name == generic_name => {
                *ty = concrete_type.clone();
            }
            // TODO: grouped
            Type::Array { element_type, .. } => {
                self.substitute_in_type(element_type, generic_name, concrete_type);
            }
            Type::Tuple(element_types) => {
                for elem_type in element_types {
                    self.substitute_in_type(elem_type, generic_name, concrete_type);
                }
            }
            // TODO: function pointer
            Type::Reference { inner_type, .. } => {
                self.substitute_in_type(inner_type, generic_name, concrete_type);
            }
            Type::Vec { element_type } => {
                self.substitute_in_type(element_type, generic_name, concrete_type);
            }
            // TODO: mapping
            Type::Option { inner_type } => {
                self.substitute_in_type(inner_type, generic_name, concrete_type);
            }
            Type::Result { ok_type, err_type } => {
                self.substitute_in_type(ok_type, generic_name, concrete_type);
                self.substitute_in_type(err_type, generic_name, concrete_type);
            }
            _ => {}
        }
    }

    fn substitute_in_struct_def(
        &mut self,
        struct_def: &mut StructDef,
        generic_name: &Identifier,
        concrete_type: &Type,
    ) {
        if let Some(fields) = struct_def.fields_opt.as_mut() {
            for field in fields {
                self.substitute_in_type(&mut field.field_type, generic_name, concrete_type);
            }
        }
    }

    fn substitute_in_function(
        &mut self,
        function: &mut FunctionItem,
        generic_name: &Identifier,
        concrete_type: &Type,
    ) {
        if let Some(params) = function.params_opt.as_mut() {
            for param in params {
                self.substitute_in_type(&mut param.param_type(), generic_name, concrete_type);
            }
        }

        if let Some(return_type) = function.return_type_opt.as_mut() {
            self.substitute_in_type(return_type, generic_name, concrete_type);
        }
    }

    /// Checks if a given type satisfies a specific trait bound.
    fn type_satisfies_bound(&self, concrete_type: &Type, bound_trait: &TraitDef) -> bool {
        // retrieve all the trait implementations for the concrete type from the symbol table
        // or registry
        let trait_implementations = self.get_trait_implementations(concrete_type);

        // check if any of the implementations match the required trait
        for trait_impl in trait_implementations.iter() {
            if self.trait_matches(trait_impl, bound_trait) {
                return true;
            }
        }

        // if no matching trait implementations were found, the bound is not satisfied
        false
    }

    fn get_trait_implementations(&self, concrete_type: &Type) -> Vec<TraitImplDef> {
        // convert concrete type to its `TypePath` representation
        if let Some(type_path) = self.resolve_type_path(concrete_type).as_ref() {
            // look up the trait implementations in the type table
            if let Some(trait_impls) = self.type_table.get(type_path) {
                return trait_impls.clone();
            }
        }

        // if no implementations are found, return an empty vector
        Vec::new()
    }

    /// Helper function to resolve `Type` to `TypePath`.
    fn resolve_type_path(&self, ty: &Type) -> Option<TypePath> {
        match ty {
            Type::UserDefined(type_path) => Some(type_path.clone()),
            _ => None,
        }
    }

    /// Check if the trait implementation matches the required trait.
    fn trait_matches(&self, trait_impl: &TraitImplDef, bound_trait: &TraitDef) -> bool {
        // TODO: check the path and the associated generic parameters
        // TODO: compare full paths and resolve them properly.
        trait_impl.implemented_trait_path.type_name == bound_trait.trait_name
    }

    fn log_error(&mut self, error_kind: SemanticErrorKind, span: &Span) {
        let error = CompilerError::new(error_kind, span.start(), &span.input());

        self.logger.error(&error.to_string());

        self.errors.push(error);
    }
}

/// Attempt to unify the types of two `Result` types, specifically between an inferred type
/// and a context type. This function is used to ensure that the `Ok` and `Err` variants of
/// an inferred `Result` type match the expected types defined in the context.
fn unify_result_types(
    inferred_type: &mut Type,
    context_type: &Type,
) -> Result<(), SemanticErrorKind> {
    let inferred_type_clone = inferred_type.clone();

    match (inferred_type, context_type) {
        (
            Type::Result {
                ok_type: inf_ok,
                err_type: inf_err,
            },
            Type::Result {
                ok_type: ctx_ok,
                err_type: ctx_err,
            },
        ) => {
            if **inf_ok
                == Type::InferredType(InferredType {
                    name: Identifier::from("_"),
                })
            {
                *inf_ok = ctx_ok.clone();
            } else if **ctx_ok
                != Type::InferredType(InferredType {
                    name: Identifier::from("_"),
                })
                && **inf_ok != **ctx_ok
            {
                return Err(SemanticErrorKind::TypeMismatchResultExpr {
                    variant: Keyword::Ok,
                    expected: *ctx_ok.clone(),
                    found: *(*inf_ok).clone(),
                });
            }

            if **inf_err
                == Type::InferredType(InferredType {
                    name: Identifier::from("_"),
                })
            {
                *inf_err = ctx_err.clone();
            } else if **ctx_err
                != Type::InferredType(InferredType {
                    name: Identifier::from("_"),
                })
                && **inf_err != **ctx_err
            {
                return Err(SemanticErrorKind::TypeMismatchResultExpr {
                    variant: Keyword::Err,
                    expected: *ctx_err.clone(),
                    found: *(*inf_err).clone(),
                });
            }
            Ok(())
        }
        _ => Err(SemanticErrorKind::UnexpectedType {
            expected: context_type.to_string(),
            found: inferred_type_clone,
        }),
    }
}
